# 常用的数据结构

## 1. 数组, 字符串

#### 1. 1 数组

- 优点

  构建一个数组非常简单

  能让我们在$O(1)$ 的时间里根据数组的下标 (index) 查询某个元素

- 缺点

  构建时必须分配一段连续的空间

  查询某个元素是否存在时需要遍历整个数组, 耗费$O(n)$的时间, $n$ 是元素的个数\

  删除或者添加某个元素时, 同样需要耗费$O(n)$的时间

## 2. 链表

### 2.1 l链表(LinkedList)

- 单链表: 链表中的每个元素实际上是一个单独的对象，而所有对象都通过每个元素中的引用字段链接在一起。
- 双链表: 与单链表不同的是，双链表的每个结点中都含有两个引用字段.

### 2.2 链表的优缺点

链表的优点:

- 链表能灵活的分配内存空间;
- 能在$O(1)$ 时间内删除或者添加元素, 前提是该元素的前一个元素已知, 当然也取决于单链表还是双链表, 在双链表中, 如果已知该元素的后一个元素, 同样可以在$O(1)$ 时间内删除或者添加该元素

链表的缺点:

- 不能像数组通过下标迅速读取元素, 每次都要从链表头开始一个一个读取;
- 查询第K个元素需要$O(k)$时间.

### 2.3 应用场景

​		如果要解决的问题里面需要很多快速查询，链表可能并不适合；如果遇到的问题中，数据的元素个数不确定，而且需要经常进行数据的添加和删除，那么链表会比较合适。而如果数据元素大小确定，删除插入的操作并不多，那么链表会比较合适。而如果数据元素大小确定，删除插入的操作并不多，那么数组可能更适合.

## 3. 栈

### 3.1 栈(Stack)

**特点**: 栈的最大特点就是后进先出（LIFO). 对于栈中的数据来说, 所有操作都是在栈的顶部完成的,

只可以查看栈顶部的元素, 只能够向栈的顶部压入数据, 也只能从栈的顶部弹出数据.

### 3.2 实现

利用一个单链表来实现栈的数据结构。而且，因为我们都只针对栈顶元素进行操作，所以借用单链表的头就能让所有栈的操作在 O(1) 的时间内完成.

### 3.3 应用场景

在解决某个问题的时候，只要求关心最近一次的操作，并且在操作完成了之后，需要向前查找到更前一次的操作。

## 4. 队列(Queue)

### 4.1 特点

和栈不同, 队列的最大的特点是先进先出(FIFO), 就好像顺序队列一样. 对于队列的数据来说, 我只允许在队尾查看和添加数据, 在队头查看和删除数据.

### 4.2 实现

可以借助双列表实现队列. 双链表的头指针允许在队头查看和删除数据, 而双链表的队尾指针, 允许我们在队尾查看和添加数据.

###  4.3 应用场景

直观来看，当我们需要按照一定的顺序来处理数据，而该数据的数据量在不断地变化的时候，则需要队列来帮助解题.... **广度优先搜索(Breadth-First Search)** 

## 5. 双端队列(Deque)

#### 4.1 特点

双端队列和普通队列最大的不同在于, 它允许我们在队列的头尾两端都能在 $O(1)$ 的时间内进行数据的查看, 添加和删除.

#### 4.2 实现

与队列相似, 我们可以利用一个双链表实现双端队列.

#### 4.3 应用场景

双端队列最常用的地方就是实现一个长度动态变化的窗口或者连续区间.

## 6. 树(Tree)

树的结构十分直观，而树的很多概念定义都有一个相同的特点：递归，也就是说，一棵树要满足某种性质，往往要求每个节点都必须满足。例如，在定义一棵二叉搜索树时，每个节点也都必须是一棵二叉搜索树.

#### 4.1树的形状

常见的树: 普通二叉树, 平衡二叉树, 完全二叉树, 二叉搜索树, 四叉树(Quadtree) , 多叉树(N-ary Tree)

特殊的树:

- 红黑树(Red-Black Tree)
- 自平衡二叉搜索树(AVL Tree)

#### 4.2 树的遍历

1. 前序遍历(Preorder Traversal)

   先访问跟节点, 然后访问左子树, 最后访问右子树. 在访问左右子树的时候, 同样, 先访问子树的根节点, 在访问子树根节点的左子树和右子树.

   ![img](http://www.lgstatic.com/i/image2/M01/90/E9/CgotOV2IRUqAYTBNAHdENl7o0CI095.gif)

   应用场景: 运用最多的场合包括在树里进行搜索以及创建一颗新的树.

2. 中序遍历(Inorder Traversal)

   先访问左子树，然后访问根节点，最后访问右子树，在访问左、右子树的时候，同样，先访问子树的左边，再访问子树的根节点，最后再访问子树的右边.

   ![img](http://www.lgstatic.com/i/image2/M01/90/E9/CgotOV2IRWCAF4adALLk-4fku-E775.gif)

   应用场景: 最常见的二叉素树,  由于二叉搜索树的性质就是左孩子小于跟节点, 根节点小于右孩子,

   对二叉搜索树进行中序遍历的时候, 被访问到的节点大小是按顺序进行的.

3. 后序遍历(Postorder Traversal)

   先访问左子树, 然后访问右子树, 最后访问根节点.

   ![img](http://www.lgstatic.com/i/image2/M01/90/CA/CgoB5l2IRW6AKLrvAL5-qvzxLkw345.gif)

   应用场景：在对某个节点进行分析的时候，需要来自左子树和右子树的信息。收集信息的操作是从树的底部不断地往上进行，好比你在修剪一棵树的叶子，修剪的方法是从外面不断地往根部将叶子一片片地修剪掉.


# 高级的数据结构

##  1. 优先队列 (Priority Queue)

### 1.1特点

能保证每次取出的元素都是队列中优先级别最高的。优先级别可以是自定义的，例如，数据的数值越大，优先级越高；或者数据的数值越小，优先级越高。优先级别甚至可以通过各种复杂的计算得到。

### 1.2 应用场景

从一堆杂乱无章的数据当中按照一定的顺序(或者优先级)逐步地筛选出部分乃至全部的数据.

### 1.3 实现

优先队列的本质是一个二叉堆结构. 堆在英文里叫 Binary Heap, 它是利用一个数组结构来实现的完全二叉树. 换句话说, 优先队列的本质是一个数组,  数组里的每个元素即有可能是其他元素的父节点, 也有可能是其他元素的子节点, 而且, 每个父节点只能有两个子节点, 很像一颗二叉树的结构.

### 1.4 性质

1. 数组里的第一个元素 array[0]拥有最高的优先级别.
2. 给定一个下标 i, 那么对于元素 array[i] 而言:
   - 它的父节点所对应的元素的下标是 $(i-1)/2$
   - 它的左孩子所对应的元素下标是 $2*i + 1$
   - 它的右孩子所对应的元素下标是$2*i + 2$
3. 数组里每个元素的优先级别都高于它两个孩子的优先级别.

### 1.5 操作

#### 1. 向上筛选(sift up/bubble up)

- 当有新数据加入到优先队列中, 新的数据首先被放置在二叉堆的底部.
- 不断进行向上筛选的操作, 即如果发现该数据的优先级别比父节点的优先级别还要高, 那么就和父节点的元素互换, 再接着往上进行比较, 直到无法再继续交换为之.

![img](http://s0.lgstatic.com/i/image2/M01/90/EC/CgotOV2ISXaAJ9iGACXUNreouXo038.gif)

> 时间复杂度: 由二叉堆是一颗完全二叉树, 并假设堆的大小为k, 因此整个过程其实就是沿着树的高度往上爬, 所以只需要 $O(log_2^k)$ 的时间.

#### 2. 向下筛选(sift down/ bubble down)

- 当堆顶的元素被取出时,  需要更新堆顶的元素作为下一次按照优先级顺序被取出的对象, 需要堆底部的元素放置到堆顶, 然后不断对它执行向下筛选的操作.

- 将该元素和它得两个孩子节点对比优先级, 如果优先级最高的是其中一个孩子, 就将该元素和那个孩子进行交换, 然后反复进行下去, 直到无法继续交换为止.

  ![img](http://s0.lgstatic.com/i/image2/M01/90/CC/CgoB5l2ISa-Af-7tAB97MaSBBWo211.gif)

> 时间复杂度: 整个过程就是沿着树的高度往下爬, 所以时间复杂度也是$O(log_2^k)$
>
> 因此, 无论是添加新的数据还是取出堆顶的元素, 都需要$O(log_2^k)$的时间.

### 1.6 初始化

优先队列的初始化是一个最重要的时间复杂度，是分析运用优先队列性能时必不可少的，也是经常容易弄错的地方。

例如: 有 n 个数据, 需要创建一个大小为 n 的堆.

误区: 每当把一个数据加入到堆里，都要对其执行向上筛选的操作，这样一来就是 O(nlogn)。

解法:
$$
T(n) = \sum_{h=0}^{lg(n)} [\frac{n}{2^(h+1)}] * O(h) \\
= O(n*\sum_{h=0}^{lg(n)}\frac{h}{2^h}) \\
= O(n * \sum_{h=0}^{\infin}\frac{h}{2^h})
$$
**初始化一个大小为n的堆, 所需要的时间是$O(n)$**

## 2. 图 (Graph)

### 2.1 基本知识点

- 阶(Order),  度: 出度(Out-Degree), 入度(In-Degree)
- 树(tree),  森林(Forest), 环(Loop)
- 有向图(Directed Graph), 无向图(Undirected Graph), 完全有向图, 完全无向图.
- 连通图(Connected Graph), 连通分量(Connected Component)
- 存储和表达式: 邻接矩阵(Adjacency Matrix),  邻接链表(Adjacency List)

### 2.2 相关的算法

- 图的遍历: 深度优先, 广度优先
- 环的检测: 有向图, 无向图.
- 拓扑排序
- 最短路径算法: Dijkstra , Bellman-Ford, Floyd Warshall
- 连通性相关算法: Kosaraju, Tarjan, 求解孤岛的数量, 判断是否为树.
- 图的着色, 旅行商问题等

### 2.3 必须掌握的知识点

- 图的存储和表达方式: 邻接矩阵(Adjacency Matrix), 邻接链表(Adjacency List)
- 图的遍历: 深度优先, 广度优先
- 二部图的检测(Bipartite), 树的检测, 环的检测: 有向图, 无向图.
- 拓扑排序
- 联合-查找算法(Union-Find)
- 最短路径: Dijkstra , Ballman-Ford

## 3. 前缀树 (Trie)

### 3.1 应用场景

前缀树被广泛地运用在字典查找当中, 也被称为字段树.

### 3.2 性质

1. 每个节点至少包含两个基本属性

   - children: 数组或者集合, 罗列出每个分支中包含的所有字符.
   - isEnd: 布尔值, 表示该节点是否为某字符串的结尾

2. 前缀树的根节点是空的.

   所谓的空, 即只利用到这个节点的children 属性, 即只关系这个字典中, 有哪些大头的字符.

3. 除了跟节点, 其他所有节点都有可能是单词的结尾, 叶子节点一定都是单词得结尾.

### 3.3 实现

1. 创建

   - 遍历一遍输入的字符串, 对每个字符串的字符进行遍历
   - 从前缀的根节点开始, 对每个字符加入到节点的children 字符集当中.
   - 如果字符集已经包含了这个字符, 则跳过.
   - 如果当前字符是字符串的最后一个, 则把当前节点的isEnd 标记为真.

   前缀树 真正强大的地方在于, 每个节点还能用来保存额外的信息, 比如可以用来记录拥有相同前缀的所有字符串. 因此, 当用户输入某个前缀时, 就能在$O(1)$的时间内给出对应的推荐字符串.

2. 搜索

   与创建方法类似, 从前缀树的根节点出发, 逐个匹配输入的前缀字符, 如果遇到了就继续往下一层搜索, 如果没有遇到, 就立即返回.

## 4. 线段树 (Segment Tree)

- 线段树, 就是一种按照二叉树的形式存储数据的结构, 每个节点保存的都是数组里某一段的总和.
- 适用于数据很多, 而且需要频繁更新并求和的操作.
- 时间复杂度$O(log_2^n)$

## 5. 树状数组 (Fenwick Tree / Binary  Indexed Tree)

1. 它是利用数组来表示多叉树的结构, 在这一点上和优先队列有些类似, 最不过, 优先队列是用数组来表示完全二叉树, 而树状数组是多叉树.
2. 树状数组的第一个元素的空节点.
3. 如果节点tree[y] 是 tree[x] 的父节点, 那么需要满足条件: $y= x - (x \and (-x))$