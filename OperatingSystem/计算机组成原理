

# 1| 计算机是什么

## 芯片: 计算能源

## 摩尔定律: 计算能力的发展

## 可计算理论: 图灵机

## 公理化体系和不完备性定理

计算机能力也是有边界的。哥德尔的不完备性定理，世界上还有大量不可计算的问题。

## 图灵机和可计算理论

可计算理论: 那些问题可以被计算，那些问题不可以被计算。

## 不可计算问题

## 停机问题

我们无法实现用一个通用程序去判断另一个程序是否会停止。

## 问题的分类

- 时间开销，空间开销都不会随着问题规模增长  O(1)
- 时间开销会随着问题规模线性增大 O(N), N是问题的规模
- 时间开销会随着问题规模的平方增长。 O($N^2$)

## P 问题 vs NP 问题

P问题 多项式（Polynomial time）时间问题

## 人工智能

# 02｜程序的执行

## 冯诺依曼模型

![1.png](https://s0.lgstatic.com/i/image/M00/4E/A2/CgqCHl9e5VaANB2BAAEVncqxxwI213.png)

- 输入设备

- 输出设备

- 内存

  程序和数据被存储在一个被称为内存的线性排列存储区域。

  存储的数据单位是一个二进制位， 英文是bit。

  最小的存储单位叫作字节，也是8位 byte.

  每一个字节都对应一个内存地址.

  从0开始,然后自增排列，最后一个地址是内存中的字节数减1.

- 中央处理器

- 总线

## 内存

程序和数据被存储在一个被称为内存的线性排列存储区域。

存储的数据单位是一个二进制位， 英文是bit。

最小的存储单位叫作字节，也是8位 byte.

每一个字节都对应一个内存地址.

从0开始,然后自增排列，最后一个地址是内存中的字节数减1.

我们通常说的内存都是随机存取器，也就是读取任何一个地址数据的速度都是一样的，
写入任何一个地址数据的速度也是一样的。

## CPU

冯诺依曼模型中 CPU负责控制和计算。

- 如果CPU每次可以计算4个byte, 那么我们称为32位CPU
- 如果CPU每次可以计算8个byte, 那么我们称为64位CPU

这里的 32 和 64，称为CPU的位宽.


## 控制单元和逻辑运算单元

CPU 中有一个控制单位专门负责控制CPU工作;还有逻辑运算单元专门负责计算。

## 寄存器

计算机用来存储将要被计算的数字，这种存储就是寄存器。

- 寄存器中有一部分是可供用户编程用的，比如用来存加和指令的两个参数，是通用寄存器。
- 还有一部分寄存器有特殊的用途，叫作特殊寄存器
- 下一条要执行的指令，会从内存读入到另一个特殊的寄存器中，这个寄存器叫作指令寄存器。指令被执行玩之前，指令都存储在这里

## 总线

CPU和内存以及其他设备之间，也需要通信，因此我们用一种特殊的设备进行控制，就是总线。

- 地址总线，专门用来指定CPU将要操作的内存地址
- 还有一种是数据总线，用来读写内存中的数据。

当CPU需要读写内存的时候，先要通过地址总线来指定内存地址，再通过数据总线来传输数据。

- 控制总线，用来发送和接受关键信号，比如中断信号，还有设备复位，就绪信号，都是通过控制总线传输。同样的，CPU需要对这些信号进行响应，这也需要控制总线。

## 输入，输出设备

向计算机输入数据，计算机经过计算，将结果通过输出设备向外传达。

1. 线路位宽问题

   线路传输是通过操作电压，低电压是0，高电压是1.
   一个bit 一个bit 发送的方式，我们叫做串行。如果希望每次多传一些数据，就需要增加线路，也就是需要并行。

2. 64位和32位的计算
   32 位宽的CPU 控制40位宽的地址总线，数据总线工作会非常麻烦，需要双方制定协议。因此通常32位宽CPU最多操作32位宽的地址总线和数据总线。

​        因此必须把两个64位数字拆成2哥32为数字来计算，这样就需要一个算法来转换

​		64位的CPU就可以一次读入64位的数字，同时64位的CPU内部的逻辑计算单位，

​		也支持64位的数字进行计算。**千万不要仅仅因为位宽的区别，就认为64位CPU性能比32位高很多。**


 		32位宽的CPU没办法控制超过32位的地址总线，数据总线工作，因为它最多只有32位的寄存器。因此

​	 	32位位宽的CPU最多可以操作$$2^{32}$$个内存地址，也就是4G内存地址。

## 程序的执行过程

当CPU执行程序的时候:

1. 首先，CPU读取PC指针指向的指令，将它导入指令寄存器。具体来说，完成读取指令这件事有3个步骤

   - CPU的控制单元操作地址总线指定需要访问的内存地址（简答理解，就是把PC指针中的值拷贝到地址总线中）。

   - CPU通知内存设备准备数据（内存设备准备好了，就通过数据总线将数据传给CPU）。

   - CPU收到内存传来的数据后，将这个数据存入指令寄存器。

   完成以上3步，CPU成功读取了PC指针指向指令，存入了指令寄存器。

2. 然后，CPU分析指令寄存器的指令，确定指令的类型和参数。

3. 如果是计算类型的指令，那么就交给逻辑运算单元计算；如果是存储类型的指令，那么由控制单元执行。

4. PC指针自增，并准备获取下一条指令。

   >比如在32位的机器上，指令是32位4个字节，需要4个内存地址存储，因此PC指针会自增4.

![图片1 (1).png](https://s0.lgstatic.com/i/image/M00/4E/C8/Ciqc1F9fGs2AEfeRAADnPPOm_gU294.png)

 

## 指令

![12.png](https://s0.lgstatic.com/i/image/M00/4E/EA/CgqCHl9fMJiAXO1-AABvVvPHepg435.png)

- 最左边的6位，叫做操作码，英文是OpCode, 100011 代表load指令;
- 中间4位 0000 时寄存器的编码，这里代表寄存器R0;
- 后面的22位代表要读取的地址，也就是0x100.

Add 指令，16进制表示是 0x08048000 , 换算成 二进制就是:

![11.png](https://s0.lgstatic.com/i/image/M00/4E/DF/Ciqc1F9fMKGAT9ymAACIAk1pGnk727.png)

- 最左边的 6 位是指令编码，代表指令 add；
- 紧接着的 4 位 0000 代表寄存器 R0；
- 然后再接着的 4 位 0001 代表寄存器 R1；
- 再接着的 4 位 0010 代表寄存器 R2；
- 最后剩下的 14 位没有被使用。

构造指令的过程，叫作指令的编码，通常由编译器完成；解析指令的过程，叫作指令的解码，由CPU完成。

由于可见 CPU 内部有一个循环：

1. 首先CPU通过 PC 指针读取对应内存地址的指令，我们将这个步骤叫作 Fetch，就是获取的意思。

2. CPU 对指令进行解码，我们将这个部分叫作 Decode

3. CPU 执行指令，我们将这个部分叫作Execution.

4. CPU 将结果存回寄存器或者将寄存器存入内存，我们将这个步骤叫作Store

   ![image (1).png](https://s0.lgstatic.com/i/image/M00/4E/DF/Ciqc1F9fMKiAZhMVAABIVEePzcA916.png)

这个四个步骤，我们叫作CPU的指令周期。CPU的工作就是一个周期接着一个周期，周而复始。

## 指令类型

不同类型（不同OpCode）的指令，**参数**个数，每个参数的位宽，都不一样。而参数可以是以下三种类型:

- 寄存器
- 内存地址
- 数值（一般是整数和浮点）。

寄存器，内存地址还是数值，他们都是数字。

指令从**功能角度**来划分，大概有以下5类:

1. I/0 类型的指令，比如处理和内存间数据交换的指令 store/load 等; 再比如将一个内存地址的数据转移到另一个内存地址的mov 指令。
2. 计算类型的指令，最多只能处理两个寄存器，比如加减乘除，运算位，比较大小等。
3. 跳转类型的指令，用处就是修改PC指针。比如编程中大家经常会遇到需要条件判断+跳转的逻辑，比如 if - else, swtich-case ,函数调用等。
4. 信号类型的指令，比如发送中断的指令trap。
5. 闲置CPU的指令nop, 一般CPU都有一条指令，执行后CPU会空转一个周期。

**寻址模式**，比如同样是求和指令。

1. 将两个寄存器的值相加的 add 指令。
2. 将一个寄存器和一个整数相加的 addi 指令。

同样是加载内存中的数据到寄存器的load 指令也有不同的寻址模式：

1. 比如直接加载一个内存地址中的数据到寄存器的指令 la, 叫作直接寻址。
2. 直接将一个数值导入寄存器的指令 li, 叫作寄存器寻址。
3. 将一个寄存器中的数值作为地址，然后再去加载这个地址中数据的指令lw, 叫作间接寻址。

**因此寻址模式是从指令如何获取数据的角度，对指令的一种分类，目的是给编写指令的人更多选择。**



## 指令的执行速度

CPU是用石英晶体产生的脉冲转化为时钟信号驱使的，每一次时钟信号高低电平的转换就是一个周期，称为**时钟周期**。 CPU的主频，说的就是时钟信号的频率，比如一个1GHz的 CPU，说的时钟信号的频率是1G。

# 04|构造复杂的程序



