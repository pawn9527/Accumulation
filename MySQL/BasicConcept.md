# MySQL基础概念

## 01|基础架构

### 逻辑架构图

![img](https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png)

> MySQL 可以分为Server 层和存储索引擎层两部分呢

- Server 层包括连接器，查询缓存，分析器，优化器， 执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数(如内容，时间，数学和加密函数等)， 所有跨存储引擎的功能都在这一层实现，比如存储过程，触发器，视图等。
- 存储引擎  负责数据的存储和提取。

### 连接器

> 连接器负责跟客户端建立链接，获取权限，维持和管理连接。

```shell
mysql -h$ip -P$port -u$user -p
```

- 链接失败， 客户端程序结束执行
- 链接成功，连接器会到权限表里面查出你拥有的权限。 之后，这个连接里面的权限判断逻辑，都将依赖此时读到的权限。

### 查询缓存

MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句以及结果可能以 key-value 对的形式， 被直接缓存在内存中。

**查询缓存的失效非常频繁，只要有对一个表的更新，这个表所有的查询缓存都会被清空**

禁用查询缓存:

​	将 query_cache_type 设置为  DEMAND

> MySQL 8.0 已经移除查询缓存

### 分析器

分析器先会做“语法分析”， 语法分析器会根据语法规则，判断你输入的这个SQL 语句是否满足MySQL 语法

```mysql

mysql> elect * from t where ID=1;

ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'elect * from t where ID=1' at line 1
```

### 优化器

> 优化器是表里面有多个索引的时候，决定使用那个索引; 或者在一个语句有多表关联(join)的时候，决定各个表的连接顺序。

### 执行器

1. 校验权限
2. 会根据表的引擎定义，去使用这个引擎提供的接口
3. 将执行结果集合返回给客户端

## 02|日志系统

### redo  log (重做日志)

**redo log 是InnoDB 引擎特有的日志**

当有一条记录需要更新的时候 InnoDB引擎就会先把记录写到 redo log 里面，并更新内存， 这个时候更新就算完成了。 同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面。

redo log  写入规则

​	则 redo log  从头开始写，写到末尾就又回到开头循环写

![img](https://static001.geekbang.org/resource/image/16/a7/16a7950217b3f0f4ed02db5db59562a7.png)

write pos 是当前记录的位置， 一边写一边后移

checkpoint 是当前要擦除的位置， 也是往后推移并且循环的， 擦除记录前要记录更新到数文件

有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 **crash-safe**。

### binlog (归档日志)

binlog 是 MySQL  Server层的日志。

binlog  两种模式

- statement 格式的话是记SQL 语句的
- row 格式会记录行的内容， 记录两条， 更新前和更新后都有

binlog 和 redo log 三点不同

- redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。
- redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。
- redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。

![img](https://static001.geekbang.org/resource/image/2e/be/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png)

浅色框 表示是在InnoDB 内部执行的

深色框 表示是在执行器中执行的

**redo log 将写入拆分为两个步骤: prepare 和 commit**

> 如果不使用“两阶段提交” 那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致

## 03| 事务隔离

### 隔离性与隔离级别

事务特性:  ACID(Atomicity, Consistency, Isolation, Durability, 即原子性，一致性，隔离性, 持久性)

SQL 标准的事务隔离级别

- 读未提交(read uncommitted):  一个事务还没提交时，它做的变更就能被别的事务看到。
- 读提交(read committed): 一个事务提交之后，它做的变更才会被其他事务看到。
- 可重复读(repeatable read): 一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的
- 串行化(serializable)  顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

eg:  假设数据表 T 中只有一列，其中一行的值为 1，下面是按照时间顺序执行两个事务的行为。

```mysql
mysql> create table T(c int) engine=InnoDB;
insert into T(c) values(1);
```

![img](https://static001.geekbang.org/resource/image/7d/f8/7dea45932a6b722eb069d2264d0066f8.png)

- 若隔离级别是: 读为提交 

  v1=2  这个时候B还未提交，但是结果已经被A看到了因此，V2, V3 也都是2

- 若隔离级别是: 读提交  

  则 v1 = 1  v2 = 2  事务B的更新在提交后才能被A看到， 所以V3 的值也是2

- 若隔离级别是: 可重复读

  则 v1 = v2 = 1  v3 = 2 之所以 v2 还是1, 遵循的就是这个要求: 事务在执行期间看到的数据前后必须是一致的

- 若隔离级别是: 串行化

  则在事务B执行 “将1改为2”的时候， 会被锁住。 直到事务A提交之后， 事务B才可以继续执行。所以从A的角度看，v1 v2 值是1， v3 的值是 2

不同的事务隔离级别 对应的干扰

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
| :------: | :--: | :--------: | :--: |
| 读未提交 |  √   |     √      |  √   |
|  读提交  |  ×   |     √      |  √   |
| 可重复读 |  ×   |     ×      |  √   |
|  串行化  |  ×   |     ×      |  ×   |

### 事务隔离的实现

 在 MySQL 中，实际上每条记录在更新哦时候都会同时记录一条回滚操作。记录上的最新的值，通过回滚操作，都可以得到前一个状态的值。

![img](https://static001.geekbang.org/resource/image/d9/ee/d9c313809e5ac148fc39feff532f0fee.png)

### 事务的启动方式

1. 显式启动事务语句:  begin 或 start transaction。 配套的提交语句是commit, 回滚语句是 rollback
2.  set autocommit =0 , 这个命令会将这个线程的自动提交关掉。意味 着你只执行一个select 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行commit 或  rollback 语句， 或者断开连接。

如何查找长事务.

在  information_schema 库的 innodb_trx 这个表中查询长事务，比如这个

这个语句，用于查找持续时间超过60s的事务。

```mysql

select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60
```

## 04 | 索引

> 索引的出现其实就是为了提高数据查询的效率，就像书的目录一样

###  索引的常见模型

- 哈希表

  哈希表是一种以键-值(key-value)存储数据的结构，因为哈希表不是有序的，所以做区间查询的速度是很慢的。

  哈希表这种结构适用于只有等值查询的场景，比如Memcached 及其它一些NoSQL索引。

- 有序数组

  有序数组在等值查询和范围查询场景中的性能就都非常优秀，如果哦仅仅看查询效率，有序数组就死最好的数据结构了，但是在需要更新数据的成本较高(维护这个有序列表)。

  **所以 有序数组索引只适用与静态存储引擎**

- 搜索树(以二叉搜索树为例)

  二叉搜索树的特点: 父节点左子树所有节点的值小于父节点的值, 右子树所有节点的值大于父节点的值。

  查询时间复杂度: O(log(N))

### InnoDB的索引模型

在 InnoDB 中, 表都是根据主键顺序一索引的形式存放的，这种存储方式的表称为 索引组织

- 主键索引

  主键索引的叶子节点存的是整行数据。在InnoDB里面，主键索引也被成为聚簇索引(clustered index)

- 非主键索引

  非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引(secondary index)

**基于非主键索引的查询需要多扫描一颗索引树， 因此应该尽量使用主键查询。**

### 索引维护

B+树为了维护索引有序性，在插入新值的时候需要做必要的维护。

自赠主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不触发叶子节点的分裂，而有业务逻辑的字段做主键，则往往不容易保证有序插入这样写数据成本相对较高。

**主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小， 所以从性能和存储空间方面考量，自赠主键往往是更加合理的选择**


B+ 树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数。



### 索引覆盖

如果查询条件是普通索引(或是联合索引的最左原则字段)，查询结果是联合索引的字段或是主键，不用回表操作，直接返回结果，减少IO磁盘读写直接读取整行数据。

**由于覆盖索引可以减少树的搜索次数， 显著提升查询性能，所以使用索引覆盖是一个常用的性能优化手段。**

### 索引下推(index condition pushdown)

> MySQL 5.6 引入，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

### 最左前缀原则

**B+树这种索引结构，可以利用索引的"最左前缀"，来定位记录。**

*在建立索引的时候，如何安排索引内的字段顺序？*

1. 第一原则，如果通过調整顺序，可以少维护一个索引，那么这个顺序往往就是需要优化考虑采用的。
2. 其次考虑的原则就是空间了(尽量减少索引使用空间)

## 05|全局锁和表锁

> MySQL 里面的锁大致可以分成全局锁，表级锁和行锁

### 全局锁

全局锁就是对整个数据库实例加锁。

```mysql
Flush tables with read lock(FTWRL)
```

使整个库都处于只读状体的时候，之后其他线程的执行语句都会被阻塞: 数据更新语句(数据的增删改)、数据定义语句(包括建表、修改表结构等) 和更新类事务的提交语句。

使用场景:

​	**做全库的逻辑备份**， 也就是把整库每个表都select 出来存成文本。

如果不枷锁，备份系统备份得到的库不是一个逻辑时间点，这个视图是逻辑不一致的。

**为了保证能够拿到视图的一致性， 就需要开启事务隔离级别可重复读**

如果使用 mysqldump 使用参数  -single-transaction 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。由于MVCC的支持，这个过程中数据是可以正常更新的。

**一致性读是好， 可以解决视图逻辑不一致的问题， 但前提是引擎要支持这个隔离级别。**

所以 single-transaction 方法只适用于所有的表使用的事务引擎的库。

### 表级锁

- 表锁

  ```mysql
  lock tables ... read/write
  ```

  与FTWRL 类似， 可以用 unlock tables 主动释放，也可以在客户端

- 元数据锁(meta data lock, MDL)

  MDL不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，保证读写的正确性。

  **MDL 会直到事务提交释放，在做表结构变更的时候， 你一定要小心不要导致锁住线上查询和更新。**

  >当对一个表做增删改查操作的时候，加MDL读锁;当要对表做结构变更操作的时候，加MDL写锁。

  - 读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查
  - 读写锁之间，写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。

*如何安全地给小表加字段？*

首先我们要解决长事务，事务不提交，就会一直占着MDL锁。在MySQL 的 information_schema 库的 innodb_trx 表中，你可以查到当前执行中的事务。 如果你要做 DDL变更的表刚好有长事务在执行，要考虑先暂停DDL， 或者kill 这个长事务。

**表锁一般是在数据库引擎不支持行锁的时候才会被用到的。**

## 06|行锁

> MySQL的行锁是在引擎层有各个引擎自己实现的,但病史所有的引擎都支持行锁，比如MylSAM 引擎就不支持行锁。

**在InnoDB事务中，行锁是在需要的时候才加上的，但并不是需要了就立刻释放，而是要等到事务结束时才释放。这就是两阶段锁协议。**

所以有冲突时:

​	**如果你的事务中需要锁多个行，要把最可能造成锁冲突，最可能影响并发度的锁尽量往后放。**

### 死锁和死锁检测

>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。

出现死锁的两种策略:

- 一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置
- 另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为on, 表示开启这个逻辑。

减少死锁的主要方向，就是控制访问相同资源的并发事务量。

## 07|事务隔离Dome

如何启动一个事务？

1. 一致性视图是在执行第一个快照读语句时创建的
2. 一致性视图是在创建  start transaction with consistent snapshot 时创建的。

视图概念:

- 一个是 view. 它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。 创建视图的语法是 create view ..., 而它的查询方法与表一样。
- 另一个是InnoDB 在实现MVCC 时用到的一致性读视图，即 consistent read view, 用户支持 RC(Read Committed  读提交)和RR(Repeatable Read 可重复读) 隔离级别的实现。

InnoDB 的行数据有多个版本， 每个数据版本有自己的 row trx_id 每个事务或者语句有自己的一致性视图。 普通查询语句是一致性读，一致性读会根据 row trx_id 和一致性视图确定数据版本的可见性

- 对于可重复读，查询只承认在事务启动前就已经嗯提交完成的数据;
- 对于读提交，查询只承认在语句启动前就已经提交完成的数据;

![img](https://static001.geekbang.org/resource/image/88/5e/882114aaf55861832b4270d44507695e.png)

对于当前事务的启动瞬间来说， 一个数据版本的 row trx_id

1. 如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的;
2. 如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的;
3. 如果落在黄色部分，那就包括两种情况
   1. 若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见;
   2. 若 row trx_id 不在数组中， 表示这个版本是已经提交了的事务生成的，可见。