# 精通比特币

## 作者： Andreas M Antonopoulos

## 专有名词：

- 地址

  >比特币地址（例如：1DSrfJdB2AnWaFNgSbv3MZC2m74996JafV）由一串字符和数字组成，以阿拉伯数字“1”开头。就像别人向你的email地址发送电子邮件一样，他可以通过你的比特币地址向你发送比特币。

- BIP

  >比特币改进提议 （Bitcoin Improvement Proposals 的缩写），指比特币社区成员所提交的一系列改进比特币的提议。例如，BIP0021是一项改进比特币统一资源标识符（URI）计划的提议。

- 比特币

  >“比特币”既可以指这种虚拟货币单位，也指比特币网络或者网络节点使用的比特币软件。

- 区块

  >一个区块就是若干交易数据的集合，它会被标记上时间戳和之前一个区块的独特标记。区块头经过哈希运算后会生成一份工作量证明，从而验证区块中的交易。有效的区块经过全网络的共识后会被追加到主区块链中。

- 区块链

  >区块链是一串通过验证的区块，当中的每一个区块都与上一个相连，一直连到创世区块。

- 确认

  > 当一项交易被区块收录时，我们可以说它有一次确认。矿工们在此区块之后每再产生一个区块，此项交易的确认数就再加一。当确认数达到六及以上时，通常认为这笔交易比较安全并难以逆转。

- 难度

  > 整个网络会通过调整“难度”这个变量来控制生成工作量证明所需要的计算力。

- 难度目标

  >使整个网络的计算力大致每10分钟产生一个区块所需要的难度数值即为难度目标。

- 难度调整

  >整个网络每产生2,106个区块后会根据之前2,106个区块的算力进行难度调整。

- 矿工费

  > 交易的发起者通常会向网络缴纳一笔矿工费，用以处理这笔交易。大多数的交易需要0.5毫比特币的矿工费。

- 哈希

  > 二进制数据的一种数字指纹。

- 创世区块

  > 创世区块指区块链上的第一个区块，用来初始化相应的加密货币。

- 矿工

  > 矿工指通过不断重复哈希运算来产生工作量证明的各网络节点.

- 网络

  > 比特币网络是一个由若干节点组成的用以广播交易信息和数据区块的P2P网络。

- 工作量证明

  > 工作量证明指通过有效计算得到的一小块数据。具体到比特币，矿工必须要在满足全网目标难度的情况下求解SHA256算法。

- 奖励

  > 每一个新区块中都有一定量新创造的比特币用来奖励算出工作量证明的矿工。现阶段每一区块有25比特币的奖励。

- 私钥

  > 用来解锁对应（钱包）地址的一串字符，例如5J76sF8L5jTtzE96r66Sf8cka9y44wdpJjMwCxR3tzLh3ibVPxh。

- 交易

  > 简单地说，交易指把比特币从一个地址转到另一个地址。更准确地说，一笔“交易”指一个经过签名运算的，表达价值转移的数据结构。每一笔“交易”都经过比特币网络传输，由矿工节点收集并封包至区块中，永久保存在区块链某处。

- 钱包

  > 钱包指保存比特币地址和私钥的软件，可以用它来接受、发送、储存你的比特币。

# 第一章 介绍

## 1.1 什么是比特币

> 比特币是由一系列概念和技术作为基础构建的数字货币生态系统。狭义的”比特币“代表系统中的货币单位，用于存储和传输价值。

用户只要有证明其控制权的密钥，用密钥解锁，就可以发送比特币。这些密钥通常存储在计算机的数字钱包里。拥有密钥是使用比特币的唯一条件，控制权掌握在每个人手上。

比特币是一个分布式的点对点网络系统。因此没有”中央“服务器，也没有中央发行机构。比特币是通过”挖矿“产生的，挖矿就是验证比特币交易的同时参与竞赛来解决一个数学问题。

**比特币系统包含调节挖矿难度的协议。 挖矿---在比特币网络中成果写入一个区块交易 ----的难度是动态调整的， 保证不管有多少矿工（多少CPU）挖矿，平均每10分钟只有一个矿工成功**

比特币协议还规定，每四年新币的开采量减半，同时限制比特币的最终开采量为**2100万枚**。这样，流通的比特币数量非常接近一条曲线，并将在2140年比特币达到 **2100万枚**。 由于比特币的开采速度随时间递减，从长期来看，比特币是一种通货紧缩货币。此外，不能通过“”印刷“新比特币来实现”通货膨胀“。

- 一个去中心化的点对点网络（比特币协议）
- 一个公共的交易账簿（区块链）
- 一个去中心化的数字和确定性的货币发行（分布式挖矿）
- 一个去中心化的交易验证系统（交易脚本）

## 1.2 比特币发展史

比特币系统依赖于完全透明的数学原理，这项发明本身就是开创性的，它应蔓延到了分布式计算，经济学，计量经济学领域。

**一个分布式计算问题的解决方案**

中本聪的此项发明，对“拜占庭将军”问题也是一个可行的解决方案，这是一个在分布式计算中未曾解决的问题。简单来说，这个问题包括了试图通过这个不可靠，具有潜在威胁的网络中，通过信息交流来达成一个行动协议共识。 中本聪的解决是使用了工作量证明的概念在没有中央信任机构下达成共识，这代表了分布式计算的科学突破，并已经超越了货币广泛性的适用性。它可以用来达成去中心化的网络共识来公正选举，彩票，财产登记，以及数字化公证等等。

# 第二章 比特币的原理

## 2.1 交易，区块，挖矿和区块链

![img](https://book.8btc.com/books/1/master_bitcoin/_book/2/2-1.png)

比特币交易

比特币交易是将钱从交易输入移至输出。输入的指钱币的来源，通常是之前一笔交易的输出。交易的输出则是通过关联一个密钥的方式将钱赋予一个新的所有者。目的密钥被称为安全锁（Encumbrance）。这样就给资金强加了一个要求：有签名才能在以后的交易中赎回资金。

一笔交易的输出当作另一种新交易的输入，这样随着钱从一个地址被移动到另一个地址的同时形成了一条所有权链

![img](https://book.8btc.com/books/1/master_bitcoin/_book/2/2-4.png)

### 常见的交易形式

![img](https://book.8btc.com/books/1/master_bitcoin/_book/2/2-5.png)

 一般交易： 有一个输入和两个输出

![img](https://book.8btc.com/books/1/master_bitcoin/_book/2/2-6.png)

集合型交易：多个输入到一个输出的模式。这个相当于现实生活中很多硬币和纸币零钱兑换为一个大额面钞。像这样的交易有时由钱包应用产生来清理许多在支付过程收到的小数额的找零。

![img](https://book.8btc.com/books/1/master_bitcoin/_book/2/2-7.png)

分散型交易：在比特币账簿中常见的交易形式是将一个输入分配给多个输出，即多个接收者的交易。这类交易有时被商业实体用作分配资金， 例如多个雇员发工资的情形。

**交易的传送**

比特币网络的目的就是将交易和区块传播给所有参与者

**如何传播**

钱包将新的交易给其他任意一个联接到互联网的比特币客户端。任何比特币网络节点（其他客户端）收到一个之前没有见过的有效交易时会立即将它转发给联结到自身的其他节点。因此，这个交易迅速从P2P网络中传播开来，几秒内就能到达大多数节点。

**商家变动**

如果商家应用直接链接的是Alice的钱包应用的话，Bod的钱包应用也许就是第一个收到这个交易的节点。如果是从其他节点发送过来，一样可以在几秒钟内到达商家钱包应用这里。商家的钱包会立即确认 客户的交易是一个收入支付， 因为它包含能用客户的私钥兑换的输出。 客户的钱包应用也能够独立地用之前未消费输入来确认这个交易是正确构建的，并且由于包含足够交易费会被下一个区块包含进去。这时客户就可以以一个很小的风险假定这个交易会被加到区块且被确认。

````
一个对比特币交易的常见误解是它们必须要等10分钟后被确认加进一个新区块，或等60分钟以得到六次确认后才是有效的。虽然这些确认可以确保交易已被整个网络接受，但对于像一杯咖啡这样的小额商品来说就没有必要等待那么长时间了。一个商家可以免确认来接受比特币小额支付。这样做的风险不比接受一个不是用有效身份证领取或没有签名的信用卡的风险更大，而后者是现在商家常做的事情。
````

## 2.4 比特币挖矿

这个交易现在在比特币网络上传播开来。但只有被一个称为挖矿的过程验证且加到一个区块中之后，这个交易才会成为这个共享账簿（区块链）的一部分。

比特币系统的信任是建立在计算的基础上的。交易被包在一起放进区块中时需要极大的计算量来证明，但只需要少量计算就能验证它们已被证明。

挖矿在比特币中起着两个作用：

- 挖矿在构建区块时会创造新的比特币，和一个中央银行引发的纸币很类似。每一区块创造的比特币数量时固定的，随时间会渐渐减少。
- 挖矿创建信任。挖矿确保只有在包含交易的区块上贡献了足够的计算量后，这些交易才被确认。区块越多，花费的计算量越大，意味着更多的信任。

## 2.5 区块中的挖矿记录

网络中产生的一笔交易直到成为真个比特币大账簿------ 区块链的一部分时才会被确认有效。平均10分钟，矿工会将自上一个区块以来发生的所有交易生成一个新的区块。新的交易不断地从用户钱包和应用流入比特币网络中。当比特币网络上的节点看到这些交易时，会先将它们放到各自节点维护的一个临时的未经验证的交易池中。当矿工构建一个新区块时，会将这些交易从这个交易池中拿出来放到这个新区块中，然后通过尝试解决一个非常困难的问题（也叫工作量证明）以证明这个新区块的合法性。

这些交易被加进 新区块时， 以交易费用高的优先以及其它的一些规则进行排序。

![img](https://book.8btc.com/books/1/master_bitcoin/_book/2/2-9.png)

## 2.6 消费这笔交易

![img](https://book.8btc.com/books/1/master_bitcoin/_book/2/2-10.png)

# 第三章 比特币客户端(实操 暂且跳过)

## 4.1 简介

**比特币的所有权是通过数字密钥, 比特币地址和数字签名来确立的.**

**钱包:**

> 数字密钥实际上不是存储在网络中, 二是由用户生成并存储在一个文件或简单的数据中, 而这个文件或者数据被称为钱包

钱包的作用:

存储在用户钱包中的数字密钥完全独立于比特币协议, 可由用户钱包软件生成并管理, 而无需要区块链或网络连接.

每笔比特币交易都需要一个有效的签名才会被存储在区块链. 只有有效的数字密钥才能产生有效的数字签名, 因此拥有比特币的密钥副本就拥有了该账户的比特币控制权.

密钥是成对出现的, 由一个私钥和一个公钥所组成. 公钥就像银行的账号, 而私钥就像控制账户的PIN码 或者支票的签名.

**在比特币交易的支付环节, 收件人的公钥是通过其数字指纹表示的, 称为比特币地址.**

**比特币地址**是用户经常看到的**密钥的唯一代表**, 他们只需要把比特币地址告诉其他人即可.

### 4.1.1 公钥加密和加密货币

**比特币使用 椭圆曲线乘法作为公钥加密的基础算法**

<u>比特币系统中公私钥的作用?</u>

在比特币系统中, 我们用公钥加密创建一个密钥对, 用于控制比特币的获取. 密钥对包括一个私钥, 和由其衍生出的唯一的公钥. 公钥用于接收比特币, 而私钥用于比特币支付的签名.

<u>公私钥为什么能用来交易?</u>

公钥和私钥之间的 数学关系, 使得私钥可以用来生成特定的消息的签名.  此签名可以在不泄露私钥的同时对公钥进行验证.

**公私钥的实现和存储**

> 大多数比特币钱包工具为了方便将私钥和公钥以形式对的方式存储在一起. 然而, 公钥可以由私钥计算得到. 所以只存储私钥可是可以的.

### 4.1.2  私钥和公钥

<u>公私钥的形成过程</u>

私钥(k) 是一个数字, 通常随机选出. 有了私钥, 通过使用椭圆曲线乘法将 私钥单向加密产生一个公钥(K),

 在用 公钥 使用一个单向的加密的哈希函数生成比特币地址(A).

![img](https://book.8btc.com/books/1/master_bitcoin/_book/4/Fig401.png)

### 4.1.3 私钥

本质:

就是一个随机的数字而已

作用:

- 一个比特币地址中的所有资金的控制取决于相应私钥的所有权和控制权.
- 在比特币交易中, 私钥用于生成支付比特币所需的签名 以及 证明资金的所有权.

局限:

私钥必须始终保持机密, 如果泄露那么 对应的资金也相当于泄露了.

私钥必须要进行备份, 私钥如果丢失, 那么私钥保护的比特币也将会丢失.

**生成私钥算法**

私钥可以说是1~ n-1 之间的任何数字

其中 n = 1.158 * 10 ^77 , 略小于 2 ^ 256 

实现过程

>要生成这样的一个私钥，我们随机选择一个256位的数字，并检查它是否小于n-1。从编程的角度来看，一般是通过在一个密码学安全的随机源中取出一长串随机字节，对其使用SHA256哈希算法进行运算，这样就可以方便地产生一个256位的数字。如果运算结果小于n-1，我们就有了一个合适的私钥。否则，我们就用另一个随机数再重复一次。

### 4.1.4 公钥

> 是通过椭圆曲线算法 计算私钥得到的公钥, 这是不可逆转的过程.

公式
$$
K = k * G
$$
k 是私钥

G 是被称为生成点的常数点

K 是公钥

如果反向运算, 被称为 "寻找离散对数"  -------  通过公钥K来求出 私钥k 是非常困难的, 就像去验证所有可能的k 值, 即暴力搜索.

### 4.1.5 椭圆曲线密码学解释

椭圆曲线加密算法是一种基于离散对数问题的非对称(或公钥)加密法.

![img](https://book.8btc.com/books/1/master_bitcoin/_book/4/Fig402.png)

比特币使用了 secp256K1 标准所定义的一条特殊的椭圆曲线和一系列数学常数.
$$
y^2 = (x^3 + 7) \over (F_p)  \\

y^2 |p|  = (x^3 + 7) |p|
$$


上述mod p（素数p取模）表明该曲线是在素数阶p的有限域内，也写作Fp，其中

p = $$2^{256}$$ – $$2^{32}$$ – $$2^9$$ – $$2^8$$ – $$2^7$$ – $$2^6$$ – $$2^4$$ – 1

这是个非常大的素数.

### 4.1.6 生成公钥

生成规则：

以一个随机生成的私钥K 为起点, 我们将其曲线上已定义的 生成点G相乘 已获得曲线上的 另一点, 也就是相应的公钥K , 生成点是 secp256k1 标准的一部分, **比特币密钥生成点都是相同的**
$$
K = k * G
$$
$G$ 是生成点, 在该曲线上所有的点K 是公钥.

>因为其中的数学运算是单向的，所以私钥可以转换为公钥，但公钥不能转换回私钥。 为实现椭圆曲线乘法，我们以之前产生的私钥k和与生成点G相乘得到公钥K：

![img](https://book.8btc.com/books/1/master_bitcoin/_book/4/Fig0404.png)

大多数比特币程序使用 OpenSSL 加密库进行椭圆曲线计算, 例如, 调用 EC_POINT_mul 函数,可计算得到公钥.

### 4.2 比特币地址

比特币地址是一个由数字和字母组成的字符串, 可以与任何想给你比特币的人分享.

**比特币地址与 公钥不同. 比特币地址是由公钥经过单向的哈希函数生成的.**

通常用户见到的比特币地址是经过 "==Base58Check==" 编码的, 这种 编码使用了 58个字符(一种Base58数字系统)和 检验码, 提高可读性, 避免歧义并有效防止了在地址转录和输入中产生的错误. 

![img](https://book.8btc.com/books/1/master_bitcoin/_book/4/Fig405.png)

### 4.2.1 Base58 和 Base58Check 编码

为了更简洁方便地表示长串数字,  许多计算机系统会使用一种以数字和字母组成的大于十进制的表示法.

而更进一步  Base64  使用了26个小写字母, 26个大写字母, 10个数字以及两个符号(例如 "+" 和 "/") , 用于在电子邮件这样的基于文本的媒介中传输二进制数据. Base64 通常用于编码邮件中的附件.

**Base58** 是一种基于二进制编码格式， 用于比特币和其他的加密货币中。

这种编码格式不仅仅实现了==数据的压缩==， 保持了==易读性==,  还具有==错误的诊断功能==

Base58 是 Base64 编码格式的子集中, 同样使用大小写字母和10个数字, 但舍弃了 一些容易错读和在特定字体中容易混淆的字符.
*具体地，Base58不含Base64中的0（数字0）、O（大写字母o）、l（小写字母L）、I（大写字母i），以及“+”和“/”两个字符。简而言之，Base58就是由不包括（0，O，l，I）的大小写字母和数字组成。*



**Base58Check是一种常用在比特币中的Base58编码格式，增加了错误校验码来检查数据在转录中出现的错误**。校验码长4个字节，添加到需要编码的数据之后。==校验码是从需要编码的数据的哈希值中得到的，所以可以用来检测并避免转录和输入中产生的错误==。使用Base58check编码格式时，编码软件会计算原始数据的校验码并和结果数据中自带的校验码进行对比。二者不匹配则表明有错误产生，那么这个Base58Check格式的数据就是无效的。

例如，一个错误比特币地址就不会被钱包认为是有效的地址，否则这种错误会造成资金的丢失。

为了使用Base58Check编码格式对数据（数字）进行编码，首先我们要对数据添加一个称作“版本字节”的前缀，这个前缀用来明确需要编码的数据的类型。例如，比特币地址的前缀是0（十六进制是0x00），而对私钥编码时前缀是128（十六进制是0x80）。

接下来，我们计算“双哈希”校验码，意味着要对之前的结果（前缀和数据）运行两次SHA256哈希算法：
$$
checksum = SHA256(SHA256(prefix+data))
$$


![img](https://book.8btc.com/books/1/master_bitcoin/_book/4/Fig406.png)

==**Base58Check编码: 一种Base58格式的, 有版本的, 经过校验的格式, 可以明确的对比比特币数据编码的编码格式**==

在比特币中，大多数需要向用户展示的数据都使用Base58Check编码，可以实现数据压缩，易读而且有错误检验。Base58Check编码中的版本前缀是数据的格式易于辨别，编码之后的数据头包含了明确的属性。这些属性使用户可以轻松明确被编码的数据的类型以及如何使用它们。例如我们可以看到他们的不同，Base58Check编码的比特币地址是以1开头的，而Base58Check编码的私钥WIF是以5开头的

 **Base58Check版本前缀和编码后的结果**

| 种类                        | 版本前缀 (hex) | Base58格式 |
| --------------------------- | -------------- | ---------- |
| Bitcoin Address             | 0x00           | 1          |
| Pay-to-Script-Hash Address  | 0x05           | 3          |
| Bitcoin Testnet Address     | 0x6F           | m or n     |
| Private Key WIF             | 0x80           | 5, K or L  |
| BIP38 Encrypted Private Key | 0x0142         | 6P         |
| BIP32 Extended Public Key   | 0x0488B21E     | xpub       |

### 4.2.2 密钥的格式

公钥和私钥的都可以有多种编码格式。一个密钥被不同的格式编码后，虽然结果看起来可能不同，但是密钥所编码数字并没有改变。这些不同的编码格式主要是用来方便人们无误地使用和识别密钥

**公钥的格式**

- 非压缩格式

- 压缩格式

  引入压缩格式公钥是为了减少比特币交易的字节数, 从而可以节省那些运行区块链数据库的节点磁盘空间. 大部分比特币交易包含了公钥, 用于验证用户的凭据和支付比特币.

  每个公钥有 520比特

  - 前缀
  - x 坐标
  - y 坐标 

因为y 坐标可以通过公式计算吗, 可以只存储 x 坐标, 略去y 坐标. 从而将公钥的大小和存储空间减小了256比特.

**未压缩格式公钥使用04作为前缀，而压缩格式公钥是以02或03作为前缀。**

原因: 

 因为椭圆曲线加密的公式 左边是 $y^2$, 也就是说 $y$  的解释来自一个平方根, 可能是正值也可能是负值.

当我们在素数p阶的有限域上使用二进制算术计算椭圆曲线的时候，y坐标可能是奇数或者偶数，分别对应前面所讲的y值的正负符号。因此，为了区分y坐标的两种可能值，我们在生成压缩格式公钥时，如果y是偶数，则使用02作为前缀；如果y是奇数，则使用03作为前缀。这样就可以根据公钥中给定的x值，正确推导出对应的y坐标，从而将公钥解压缩为在椭圆曲线上的完整的点坐标。

![img](https://book.8btc.com/books/1/master_bitcoin/_book/4/Fig407.png)

新旧钱包的兼容性问题:

 当私钥从钱包中被导出时，较新的比特币客户端将使用一种不同的钱包导入格式（Wallet Import Format）。这种新的钱包导入格式可以用来表明该私钥已经被用来生成压缩的公钥，同时生成的比特币地址也是基于该压缩的公钥。这个方案可以解决导入私钥来自于老钱包还是新钱包的问题，同时也解决了通过公钥生成的比特币地址是来自于压缩格式公钥还是非压缩格式公钥的问题。最后新钱包在扫描区块链时，就可以使用对应的比特币地址去查找该比特币地址在区块链里所发生的交易。

**同样的私钥，不同的格式**

| 格式           | 私钥                                                         |
| -------------- | ------------------------------------------------------------ |
| Hex            | 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD |
| WIF            | 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn          |
| Hex-compressed | 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD01 |
| WIF-compressed | KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ         |

>“压缩格式私钥”是一个不当用词！私钥不是压缩的。WIF压缩格式的私钥只是用来表明他们只能被生成压缩的公钥和对应的比特币地址。相反地，“WIF压缩”编码的私钥还多出一个字节，因为这种私钥多了后缀“01”。该后缀是用来区分“非压缩格式”私钥和“压缩格式”私钥。

## 4.4 比特币钱包

定义:

>钱包是私钥的容器，通常通过有序文件或者简单的数据库实现。

==比特币钱包只包含私钥而不是比特币。==

每一个用户有一个包含多个私钥的钱包。钱包中包含成对的私钥和公钥。用户用这些私钥来签名交易，从而证明它们拥有交易的输出（也就是其中的比特币）。比特币是以交易输出的形式来储存在区块链中（通常记为vout或txout）。

### 4.4.1 非确定性(随机)钱包

定义:

> 最早的比特币客户端, 钱包只是随机生成的私钥集合. 这种类型的钱包被称作 零型非确定钱包.

==随机钥匙的缺点就是如果你生成很多，你必须保存它们所有的副本。==

![img](https://book.8btc.com/books/1/master_bitcoin/_book/4/Fig408.png)

### 4.4.2 确定性(种子)钱包

> 确定性, 或者"种子"钱包包含通过使用单项离散方程而可从公共的种子生成的私钥. 种子是随机生成的数字.  这种数字也含有比如索引号码或者可生成私钥的 "码链".

在确定性钱包中，种子足够收回所有的已经产生的私钥，所以只用在初始创建时的一个简单备份就足以搞定。并且种子也足够让钱包输入或者输出。这就很容易允许使用者的私钥在钱包之间轻松转移输入。

### 4.4.3 助记码词汇

> 助记码词汇是英文单词序列代表(编码)用作种子对应所确定性钱包的随机数.

单词的序列足以重新创建种子，并且从种子那里重新创造钱包以及所有私钥。

在首次创建钱包时，带有助记码的，运行确定性钱包的钱包的应用程序将会向使用者展示一个12至24个词的顺序。

单词的顺序就是钱包的备份。

它也可以被用来恢复以及重新创造应用程序相同或者兼容的钱包的钥匙。

助记码代码可以让使用者复制钱包更容易一些，因为它们相比较随机数字顺序来说，可以很容易地被读出来并且正确抄写。

### 4.4.4 分层确定性钱包(BIP0032/BIP0044)

确定性钱包被开发成更容易从单个"种子"中生成许多关键的钥匙.

分层确定性钱包包含从数结构所生成的钥匙. 这种母钥匙可以生成子钥匙的序列. 这些子钥匙又可以衍生出孙钥匙, 以此吴冲类推.

![img](https://book.8btc.com/books/1/master_bitcoin/_book/4/Fig409.png)

HD钱包提供了随机(不确定性)钥匙 两个优势

- 树状结构可以被用来表达额外的组织含义

  - 不同分支, 作用不同
  - 不同分支, 可以赋予不同的环境等

- 它可以允许让使用者去建立一个公共密钥的序列而不需要访问相对的私钥.

  这可允许HD钱包在不安全的服务器中使用或者在每笔交易中发行不同的公共钥匙。公共钥匙不需要被预先加载或者提前衍生，但是在服务器中不具有可用来支付的私钥。

#### 从种子种创造HD钱包

HD钱包从单个root seed中创建，为128到256位的随机数。HD钱包的所有的确定性都衍生自这个根种子。任何兼容HD钱包的根种子也可重新创造整个HD钱包。所以简单的转移HD钱包的根种子就让HD钱包中所包含的成千上百万的密钥被复制，储存导出以及导入。

![img](https://book.8btc.com/books/1/master_bitcoin/_book/4/Fig410.png)

#### 私有子密钥的衍生

分层确定性钱包使用CKD（child key derivation)方程去从母密钥衍生出子密钥。

子密钥衍生方程是基于单项哈希方程。这个方程结合了：

- 一个母私钥或者公共钥匙 （ECDSA未压缩键）
- 一个叫做链码（256 bits）的种子
- 一个索引号（32 bits）

链码是用来给这个过程引入看似的随机数据的，使得索引不能充分衍生其他的子密钥。因此，有了子密钥并不能让它发现自己的相似子密钥，除非你已经有了链码。最初的链码种子（在密码树的根部）是用随机数据构成的，随后链码从各自的母链码中衍生出来。

![img](https://book.8btc.com/books/1/master_bitcoin/_book/4/Fig411.png)

**使用衍生的子密钥**

子私钥不能从非确定性（随机）密钥中被区分出来。

因为**衍生方程是单向方程**，所以子密钥不能被用来发现他们的母密钥。

子密钥也不能用来发现他们的相同层级的姊妹密钥。

如果你有第n个子密钥，你不能发现它前面的（第n－1）或者后面的子密钥（n＋1）或者在同一顺序中的其他子密钥。

**只有母密钥以及链码才能得到所有的子密钥。**

**没有子链码的话，子密钥也不能用来衍生出任何孙密钥。**

你需要同时有子密钥以及对应的链码才能创建一个新的分支来衍生出孙密钥。

>子密钥、对应的公共钥匙以及比特币地址都不能从随机创造的密钥和地址中被区分出来。事实是它们所在的序列，在创造他们的HD钱包方程之外是不可见的。一旦被创造出来，它们就和“正常”钥匙一样运行了。

#### 拓展密钥

**密钥衍生方程可以被用来创造钥匙树上任何层级的子密钥。**

扩展密钥可以简单地被储存并且表示为简单的将256位密钥与256位链码所并联的512位序列。

有两种扩展密钥。

扩展的私钥是私钥以及链码的结合。

它可被用来衍生子私钥（子私钥可以衍生子公共密钥）公共钥匙以及链码组成扩展公共钥匙。

#### 公共子钥匙推导

分层确定性钱包的一个很有用的特点就是可以**不通过私钥而直接从公共母钥匙派生出公共子钥匙的能力**。这就给了我们两种去衍生子公共钥匙的方法：或者通过子私钥，再或者就是直接通过母公共钥匙。

![img](https://book.8btc.com/books/1/master_bitcoin/_book/4/Fig412.png)

​							扩展母公共钥匙来创造一个子公共钥匙

#### 硬化子密钥的衍生

扩展公共钥匙衍生一个分支公共钥匙的能力是很重要的，但牵扯一些风险。

访问扩展公共钥匙并不能得到访问子私人密钥的途径. 

但是,  因为**扩展公共钥匙包含有链码**，**如果子私钥被知道或者被泄漏的话，链码就可以被用来衍生所有的其他子私钥**。

一个简单地泄露的私钥以及一个母链码，

可以暴露所有的子密钥。

更糟糕的是，子私钥与母链码可以用来推断母私钥。

为了应对这种风险, HD钱包使用了一种叫做 hardened derivation 的替代衍生方程.

这就“打破”了母公共钥匙以及子链码之间的关系。

这个硬化衍生方程使用了母私钥去推到子链码，而不是母公共钥匙。

这就在母/子顺序中创造了一道“防火墙”——有链码但并不能够用来推算子链码或者姊妹私钥。

强化的衍生方程看起来几乎与一般的衍生的子私钥相同，不同的是是母私钥被用来输入散列方程中而不是母公共钥匙

![img](https://book.8btc.com/books/1/master_bitcoin/_book/4/Fig413.png)

​							子密密钥的强化衍生: 忽略母公共密钥.

当强化私钥衍生方程被使用时，得到的子私钥以及链码与使用一般衍生方程所得到的结果完全不同的。

得到的密钥“分支”可以被用来生产不易被攻击的扩展公共钥匙，

因为它所含的链码不能被用来开发或者暴露任何私钥。

强化的衍生也因此被用来在上一层级，使用扩展公共钥匙的的密钥树中创造“间隙”。

#### 正常衍生和强化衍生的索引号码

> 没懂, 再看几遍.....

#### HD钱包密钥识别符（路径）

HD钱包中的密钥是用“路径”命名的，且每个级别之间用斜杠（/）字符来表示

由主私钥衍生出的私钥起始以“m”打头。因此，第一个母密钥生成的子私钥是m/0。第一个公共钥匙是M/0。第一个子密钥的子密钥就是m/0/1，以此类推。

密钥的“祖先”是从右向左读，直到你达到了衍生出的它的主密钥。举个例子，标识符m/x/y/z描述的是子密钥m/x/y的第z个子密钥。而子密钥m/x/y又是m/x的第y个子密钥。m/x又是m的第x个子密钥。

**HD钱包路径的例子**

| HD path     | 密钥描述                                                     |
| ----------- | ------------------------------------------------------------ |
| m/0         | 从主私钥（m）衍生出的第一个（0）子密钥。                     |
| m/0/0       | 第一个私人子密钥（m/0）的子密钥。                            |
| m/0'/0      | 第一个子强化密钥first hardened child（m/0'）的第一个常规子密钥。 |
| m/1/0       | 第2个子密钥（m/1）的第一个常规子密钥                         |
| M/23/17/0/0 | 主密钥衍生出的第24个子密钥所衍生出的第17个子密钥的第一个子密钥所衍生出的第一个子密钥。 |

#### HD钱包树状结构的导航

HD钱包树状结构提供了极大的灵活性。

每一个母扩展密钥有40已个子密钥：20亿个常规子密钥和20亿个强化子密钥。

而每个子密钥又会有40亿个子密钥并且以此类推。

只要你愿意，这个树结构可以无限类推到无穷代。

但是，又由于有了这个灵活性，对无限的树状结构进行导航就变得异常困难。

尤其是对于在不同的HD钱包之间进行转移交易，因为内部组织到内部分支以及亚分支的可能性是无穷的。

**两个比特币改进建议（BIPs）提供了这个复杂问的解决办法——通过创建几个HD钱包树的提议标准。BIP0043提出使用第一个强化子索引作为特殊的标识符表示树状结构的“purpose”**

**BIP0044 HD 钱包结构的例子**

| HD 路径          | 主要描述                                 |
| ---------------- | ---------------------------------------- |
| M/44'/0'/0'/0/2  | 第三个收到公共钥匙的主比特币账户         |
| M/44'/0'/3'/1/14 | 第十五改变地址公钥的第四个比特币账户     |
| m/44'/2'/0'/0/1  | 为了签署交易的在莱特币主账户的第二个私钥 |

## 4.5 高级密钥和地址

### 4.5.1 加密私钥（BIP0038）

私钥必须保密。私钥的机密性需求事实情况是，在实践中相当难以实现，因为该需求与同样重要的安全对象可用性相互矛盾。当你需要为了避免私钥丢失而存储备份时，会发现维护私钥私密性是一件相当困难的事情。通过密码加密内有私钥的钱包可能要安全一点，但那个钱包也需要备份。

BIP0038提出了一个通用标准，使用**一个口令加密私钥并使用Base58Check对加密的私钥进行编码**，这样加密的私钥就可以安全地保存在备份介质里，安全地在钱包间传输，保持密钥在任何可能被暴露情况下的安全性。这个加密标准使用了AES，这个标准由NIST建立，并广泛应用于商业和军事应用的数据加密。

### 4.5.2 P2SH (Pay-to-Script Hash)和多重签名地址

**以数字3开头的比特币地址是P2SH地址**

有时被错误的称谓多重签名或多重签名地址。

他们指定比特币交易中受益人作为哈希的脚本，而不是公钥的所有者

> P2SH 不一定是多重签名的交易。虽然P2SH地址通常都是代表多重签名，但也可能是其他类型的交易脚本。