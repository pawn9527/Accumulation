# 精通比特币

## 作者： Andreas M Antonopoulos

## 专有名词：

- 地址

  >比特币地址（例如：1DSrfJdB2AnWaFNgSbv3MZC2m74996JafV）由一串字符和数字组成，以阿拉伯数字“1”开头。就像别人向你的email地址发送电子邮件一样，他可以通过你的比特币地址向你发送比特币。

- BIP

  >比特币改进提议 （Bitcoin Improvement Proposals 的缩写），指比特币社区成员所提交的一系列改进比特币的提议。例如，BIP0021是一项改进比特币统一资源标识符（URI）计划的提议。

- 比特币

  >“比特币”既可以指这种虚拟货币单位，也指比特币网络或者网络节点使用的比特币软件。

- 区块

  >一个区块就是若干交易数据的集合，它会被标记上时间戳和之前一个区块的独特标记。区块头经过哈希运算后会生成一份工作量证明，从而验证区块中的交易。有效的区块经过全网络的共识后会被追加到主区块链中。

- 区块链

  >区块链是一串通过验证的区块，当中的每一个区块都与上一个相连，一直连到创世区块。

- 确认

  > 当一项交易被区块收录时，我们可以说它有一次确认。矿工们在此区块之后每再产生一个区块，此项交易的确认数就再加一。当确认数达到六及以上时，通常认为这笔交易比较安全并难以逆转。

- 难度

  > 整个网络会通过调整“难度”这个变量来控制生成工作量证明所需要的计算力。

- 难度目标

  >使整个网络的计算力大致每10分钟产生一个区块所需要的难度数值即为难度目标。

- 难度调整

  >整个网络每产生2,106个区块后会根据之前2,106个区块的算力进行难度调整。

- 矿工费

  > 交易的发起者通常会向网络缴纳一笔矿工费，用以处理这笔交易。大多数的交易需要0.5毫比特币的矿工费。

- 哈希

  > 二进制数据的一种数字指纹。

- 创世区块

  > 创世区块指区块链上的第一个区块，用来初始化相应的加密货币。

- 矿工

  > 矿工指通过不断重复哈希运算来产生工作量证明的各网络节点.

- 网络

  > 比特币网络是一个由若干节点组成的用以广播交易信息和数据区块的P2P网络。

- 工作量证明

  > 工作量证明指通过有效计算得到的一小块数据。具体到比特币，矿工必须要在满足全网目标难度的情况下求解SHA256算法。

- 奖励

  > 每一个新区块中都有一定量新创造的比特币用来奖励算出工作量证明的矿工。现阶段每一区块有25比特币的奖励。

- 私钥

  > 用来解锁对应（钱包）地址的一串字符，例如5J76sF8L5jTtzE96r66Sf8cka9y44wdpJjMwCxR3tzLh3ibVPxh。

- 交易

  > 简单地说，交易指把比特币从一个地址转到另一个地址。更准确地说，一笔“交易”指一个经过签名运算的，表达价值转移的数据结构。每一笔“交易”都经过比特币网络传输，由矿工节点收集并封包至区块中，永久保存在区块链某处。

- 钱包

  > 钱包指保存比特币地址和私钥的软件，可以用它来接受、发送、储存你的比特币。

# 第一章 介绍

## 1.1 什么是比特币

> 比特币是由一系列概念和技术作为基础构建的数字货币生态系统。狭义的”比特币“代表系统中的货币单位，用于存储和传输价值。

用户只要有证明其控制权的密钥，用密钥解锁，就可以发送比特币。这些密钥通常存储在计算机的数字钱包里。拥有密钥是使用比特币的唯一条件，控制权掌握在每个人手上。

比特币是一个分布式的点对点网络系统。因此没有”中央“服务器，也没有中央发行机构。比特币是通过”挖矿“产生的，挖矿就是验证比特币交易的同时参与竞赛来解决一个数学问题。

**比特币系统包含调节挖矿难度的协议。 挖矿---在比特币网络中成果写入一个区块交易 ----的难度是动态调整的， 保证不管有多少矿工（多少CPU）挖矿，平均每10分钟只有一个矿工成功**

比特币协议还规定，每四年新币的开采量减半，同时限制比特币的最终开采量为**2100万枚**。这样，流通的比特币数量非常接近一条曲线，并将在2140年比特币达到 **2100万枚**。 由于比特币的开采速度随时间递减，从长期来看，比特币是一种通货紧缩货币。此外，不能通过“”印刷“新比特币来实现”通货膨胀“。

- 一个去中心化的点对点网络（比特币协议）
- 一个公共的交易账簿（区块链）
- 一个去中心化的数字和确定性的货币发行（分布式挖矿）
- 一个去中心化的交易验证系统（交易脚本）

## 1.2 比特币发展史

比特币系统依赖于完全透明的数学原理，这项发明本身就是开创性的，它应蔓延到了分布式计算，经济学，计量经济学领域。

**一个分布式计算问题的解决方案**

中本聪的此项发明，对“拜占庭将军”问题也是一个可行的解决方案，这是一个在分布式计算中未曾解决的问题。简单来说，这个问题包括了试图通过这个不可靠，具有潜在威胁的网络中，通过信息交流来达成一个行动协议共识。 中本聪的解决是使用了工作量证明的概念在没有中央信任机构下达成共识，这代表了分布式计算的科学突破，并已经超越了货币广泛性的适用性。它可以用来达成去中心化的网络共识来公正选举，彩票，财产登记，以及数字化公证等等。

# 第二章 比特币的原理

## 2.1 交易，区块，挖矿和区块链

![img](https://book.8btc.com/books/1/master_bitcoin/_book/2/2-1.png)

比特币交易

比特币交易是将钱从交易输入移至输出。输入的指钱币的来源，通常是之前一笔交易的输出。交易的输出则是通过关联一个密钥的方式将钱赋予一个新的所有者。目的密钥被称为安全锁（Encumbrance）。这样就给资金强加了一个要求：有签名才能在以后的交易中赎回资金。

一笔交易的输出当作另一种新交易的输入，这样随着钱从一个地址被移动到另一个地址的同时形成了一条所有权链

![img](https://book.8btc.com/books/1/master_bitcoin/_book/2/2-4.png)

### 常见的交易形式

![img](https://book.8btc.com/books/1/master_bitcoin/_book/2/2-5.png)

 一般交易： 有一个输入和两个输出

![img](https://book.8btc.com/books/1/master_bitcoin/_book/2/2-6.png)

集合型交易：多个输入到一个输出的模式。这个相当于现实生活中很多硬币和纸币零钱兑换为一个大额面钞。像这样的交易有时由钱包应用产生来清理许多在支付过程收到的小数额的找零。

![img](https://book.8btc.com/books/1/master_bitcoin/_book/2/2-7.png)

分散型交易：在比特币账簿中常见的交易形式是将一个输入分配给多个输出，即多个接收者的交易。这类交易有时被商业实体用作分配资金， 例如多个雇员发工资的情形。

**交易的传送**

比特币网络的目的就是将交易和区块传播给所有参与者

**如何传播**

钱包将新的交易给其他任意一个联接到互联网的比特币客户端。任何比特币网络节点（其他客户端）收到一个之前没有见过的有效交易时会立即将它转发给联结到自身的其他节点。因此，这个交易迅速从P2P网络中传播开来，几秒内就能到达大多数节点。

**商家变动**

如果商家应用直接链接的是Alice的钱包应用的话，Bod的钱包应用也许就是第一个收到这个交易的节点。如果是从其他节点发送过来，一样可以在几秒钟内到达商家钱包应用这里。商家的钱包会立即确认 客户的交易是一个收入支付， 因为它包含能用客户的私钥兑换的输出。 客户的钱包应用也能够独立地用之前未消费输入来确认这个交易是正确构建的，并且由于包含足够交易费会被下一个区块包含进去。这时客户就可以以一个很小的风险假定这个交易会被加到区块且被确认。

````
一个对比特币交易的常见误解是它们必须要等10分钟后被确认加进一个新区块，或等60分钟以得到六次确认后才是有效的。虽然这些确认可以确保交易已被整个网络接受，但对于像一杯咖啡这样的小额商品来说就没有必要等待那么长时间了。一个商家可以免确认来接受比特币小额支付。这样做的风险不比接受一个不是用有效身份证领取或没有签名的信用卡的风险更大，而后者是现在商家常做的事情。
````

## 2.4 比特币挖矿

这个交易现在在比特币网络上传播开来。但只有被一个称为挖矿的过程验证且加到一个区块中之后，这个交易才会成为这个共享账簿（区块链）的一部分。

比特币系统的信任是建立在计算的基础上的。交易被包在一起放进区块中时需要极大的计算量来证明，但只需要少量计算就能验证它们已被证明。

挖矿在比特币中起着两个作用：

- 挖矿在构建区块时会创造新的比特币，和一个中央银行引发的纸币很类似。每一区块创造的比特币数量时固定的，随时间会渐渐减少。
- 挖矿创建信任。挖矿确保只有在包含交易的区块上贡献了足够的计算量后，这些交易才被确认。区块越多，花费的计算量越大，意味着更多的信任。

## 2.5 区块中的挖矿记录

网络中产生的一笔交易直到成为真个比特币大账簿------ 区块链的一部分时才会被确认有效。平均10分钟，矿工会将自上一个区块以来发生的所有交易生成一个新的区块。新的交易不断地从用户钱包和应用流入比特币网络中。当比特币网络上的节点看到这些交易时，会先将它们放到各自节点维护的一个临时的未经验证的交易池中。当矿工构建一个新区块时，会将这些交易从这个交易池中拿出来放到这个新区块中，然后通过尝试解决一个非常困难的问题（也叫工作量证明）以证明这个新区块的合法性。

这些交易被加进 新区块时， 以交易费用高的优先以及其它的一些规则进行排序。

![img](https://book.8btc.com/books/1/master_bitcoin/_book/2/2-9.png)

## 2.6 消费这笔交易

![img](https://book.8btc.com/books/1/master_bitcoin/_book/2/2-10.png)

# 第三章 比特币客户端(实操 暂且跳过)

## 4.1 简介

**比特币的所有权是通过数字密钥, 比特币地址和数字签名来确立的.**

**钱包:**

> 数字密钥实际上不是存储在网络中, 二是由用户生成并存储在一个文件或简单的数据中, 而这个文件或者数据被称为钱包

钱包的作用:

存储在用户钱包中的数字密钥完全独立于比特币协议, 可由用户钱包软件生成并管理, 而无需要区块链或网络连接.

每笔比特币交易都需要一个有效的签名才会被存储在区块链. 只有有效的数字密钥才能产生有效的数字签名, 因此拥有比特币的密钥副本就拥有了该账户的比特币控制权.

密钥是成对出现的, 由一个私钥和一个公钥所组成. 公钥就像银行的账号, 而私钥就像控制账户的PIN码 或者支票的签名.

**在比特币交易的支付环节, 收件人的公钥是通过其数字指纹表示的, 称为比特币地址.**

**比特币地址**是用户经常看到的**密钥的唯一代表**, 他们只需要把比特币地址告诉其他人即可.

### 4.1.1 公钥加密和加密货币

**比特币使用 椭圆曲线乘法作为公钥加密的基础算法**

<u>比特币系统中公私钥的作用?</u>

在比特币系统中, 我们用公钥加密创建一个密钥对, 用于控制比特币的获取. 密钥对包括一个私钥, 和由其衍生出的唯一的公钥. 公钥用于接收比特币, 而私钥用于比特币支付的签名.

<u>公私钥为什么能用来交易?</u>

公钥和私钥之间的 数学关系, 使得私钥可以用来生成特定的消息的签名.  此签名可以在不泄露私钥的同时对公钥进行验证.

**公私钥的实现和存储**

> 大多数比特币钱包工具为了方便将私钥和公钥以形式对的方式存储在一起. 然而, 公钥可以由私钥计算得到. 所以只存储私钥可是可以的.

### 4.1.2  私钥和公钥

<u>公私钥的形成过程</u>

私钥(k) 是一个数字, 通常随机选出. 有了私钥, 通过使用椭圆曲线乘法将 私钥单向加密产生一个公钥(K),

 在用 公钥 使用一个单向的加密的哈希函数生成比特币地址(A).

![img](https://book.8btc.com/books/1/master_bitcoin/_book/4/Fig401.png)

### 4.1.3 私钥

本质:

就是一个随机的数字而已

作用:

- 一个比特币地址中的所有资金的控制取决于相应私钥的所有权和控制权.
- 在比特币交易中, 私钥用于生成支付比特币所需的签名 以及 证明资金的所有权.

局限:

私钥必须始终保持机密, 如果泄露那么 对应的资金也相当于泄露了.

私钥必须要进行备份, 私钥如果丢失, 那么私钥保护的比特币也将会丢失.

**生成私钥算法**

私钥可以说是1~ n-1 之间的任何数字

其中 n = 1.158 * 10 ^77 , 略小于 2 ^ 256 

实现过程

>要生成这样的一个私钥，我们随机选择一个256位的数字，并检查它是否小于n-1。从编程的角度来看，一般是通过在一个密码学安全的随机源中取出一长串随机字节，对其使用SHA256哈希算法进行运算，这样就可以方便地产生一个256位的数字。如果运算结果小于n-1，我们就有了一个合适的私钥。否则，我们就用另一个随机数再重复一次。

### 4.1.4 公钥

> 是通过椭圆曲线算法 计算私钥得到的公钥, 这是不可逆转的过程.

公式
$$
K = k * G
$$
k 是私钥

G 是被称为生成点的常数点

K 是公钥

如果反向运算, 被称为 "寻找离散对数"  -------  通过公钥K来求出 私钥k 是非常困难的, 就像去验证所有可能的k 值, 即暴力搜索.

### 4.1.5 椭圆曲线密码学解释

椭圆曲线加密算法是一种基于离散对数问题的非对称(或公钥)加密法.

![img](https://book.8btc.com/books/1/master_bitcoin/_book/4/Fig402.png)

比特币使用了 secp256K1 标准所定义的一条特殊的椭圆曲线和一系列数学常数.
$$
y^2 = (x^3 + 7) \over (F_p)  \\

y^2 |p|  = (x^3 + 7) |p|
$$


上述mod p（素数p取模）表明该曲线是在素数阶p的有限域内，也写作Fp，其中

p = $$2^{256}$$ – $$2^{32}$$ – $$2^9$$ – $$2^8$$ – $$2^7$$ – $$2^6$$ – $$2^4$$ – 1

这是个非常大的素数.

### 4.1.6 生成公钥

生成规则：

以一个随机生成的私钥K 为起点, 我们将其曲线上已定义的 生成点G相乘 已获得曲线上的 另一点, 也就是相应的公钥K , 生成点是 secp256k1 标准的一部分, **比特币密钥生成点都是相同的**
$$
K = k * G
$$
$G$ 是生成点, 在该曲线上所有的点K 是公钥.

>因为其中的数学运算是单向的，所以私钥可以转换为公钥，但公钥不能转换回私钥。 为实现椭圆曲线乘法，我们以之前产生的私钥k和与生成点G相乘得到公钥K：

![img](https://book.8btc.com/books/1/master_bitcoin/_book/4/Fig0404.png)

大多数比特币程序使用 OpenSSL 加密库进行椭圆曲线计算, 例如, 调用 EC_POINT_mul 函数,可计算得到公钥.

### 4.2 比特币地址

比特币地址是一个由数字和字母组成的字符串, 可以与任何想给你比特币的人分享.

**比特币地址与 公钥不同. 比特币地址是由公钥经过单向的哈希函数生成的.**

通常用户见到的比特币地址是经过 "==Base58Check==" 编码的, 这种 编码使用了 58个字符(一种Base58数字系统)和 检验码, 提高可读性, 避免歧义并有效防止了在地址转录和输入中产生的错误. 

![img](https://book.8btc.com/books/1/master_bitcoin/_book/4/Fig405.png)

### 4.2.1 Base58 和 Base58Check 编码

为了更简洁方便地表示长串数字,  许多计算机系统会使用一种以数字和字母组成的大于十进制的表示法.

而更进一步  Base64  使用了26个小写字母, 26个大写字母, 10个数字以及两个符号(例如 "+" 和 "/") , 用于在电子邮件这样的基于文本的媒介中传输二进制数据. Base64 通常用于编码邮件中的附件.

**Base58** 是一种基于二进制编码格式， 用于比特币和其他的加密货币中。

这种编码格式不仅仅实现了==数据的压缩==， 保持了==易读性==,  还具有==错误的诊断功能==

Base58 是 Base64 编码格式的子集中, 同样使用大小写字母和10个数字, 但舍弃了 一些容易错读和在特定字体中容易混淆的字符.
*具体地，Base58不含Base64中的0（数字0）、O（大写字母o）、l（小写字母L）、I（大写字母i），以及“+”和“/”两个字符。简而言之，Base58就是由不包括（0，O，l，I）的大小写字母和数字组成。*



**Base58Check是一种常用在比特币中的Base58编码格式，增加了错误校验码来检查数据在转录中出现的错误**。校验码长4个字节，添加到需要编码的数据之后。==校验码是从需要编码的数据的哈希值中得到的，所以可以用来检测并避免转录和输入中产生的错误==。使用Base58check编码格式时，编码软件会计算原始数据的校验码并和结果数据中自带的校验码进行对比。二者不匹配则表明有错误产生，那么这个Base58Check格式的数据就是无效的。

例如，一个错误比特币地址就不会被钱包认为是有效的地址，否则这种错误会造成资金的丢失。

为了使用Base58Check编码格式对数据（数字）进行编码，首先我们要对数据添加一个称作“版本字节”的前缀，这个前缀用来明确需要编码的数据的类型。例如，比特币地址的前缀是0（十六进制是0x00），而对私钥编码时前缀是128（十六进制是0x80）。

接下来，我们计算“双哈希”校验码，意味着要对之前的结果（前缀和数据）运行两次SHA256哈希算法：
$$
checksum = SHA256(SHA256(prefix+data))
$$


![img](https://book.8btc.com/books/1/master_bitcoin/_book/4/Fig406.png)

==**Base58Check编码: 一种Base58格式的, 有版本的, 经过校验的格式, 可以明确的对比比特币数据编码的编码格式**==

在比特币中，大多数需要向用户展示的数据都使用Base58Check编码，可以实现数据压缩，易读而且有错误检验。Base58Check编码中的版本前缀是数据的格式易于辨别，编码之后的数据头包含了明确的属性。这些属性使用户可以轻松明确被编码的数据的类型以及如何使用它们。例如我们可以看到他们的不同，Base58Check编码的比特币地址是以1开头的，而Base58Check编码的私钥WIF是以5开头的

 **Base58Check版本前缀和编码后的结果**

| 种类                        | 版本前缀 (hex) | Base58格式 |
| --------------------------- | -------------- | ---------- |
| Bitcoin Address             | 0x00           | 1          |
| Pay-to-Script-Hash Address  | 0x05           | 3          |
| Bitcoin Testnet Address     | 0x6F           | m or n     |
| Private Key WIF             | 0x80           | 5, K or L  |
| BIP38 Encrypted Private Key | 0x0142         | 6P         |
| BIP32 Extended Public Key   | 0x0488B21E     | xpub       |

### 4.2.2 密钥的格式

公钥和私钥的都可以有多种编码格式。一个密钥被不同的格式编码后，虽然结果看起来可能不同，但是密钥所编码数字并没有改变。这些不同的编码格式主要是用来方便人们无误地使用和识别密钥

**公钥的格式**

- 非压缩格式

- 压缩格式

  引入压缩格式公钥是为了减少比特币交易的字节数, 从而可以节省那些运行区块链数据库的节点磁盘空间. 大部分比特币交易包含了公钥, 用于验证用户的凭据和支付比特币.

  每个公钥有 520比特

  - 前缀
  - x 坐标
  - y 坐标 

因为y 坐标可以通过公式计算吗, 可以只存储 x 坐标, 略去y 坐标. 从而将公钥的大小和存储空间减小了256比特.

**未压缩格式公钥使用04作为前缀，而压缩格式公钥是以02或03作为前缀。**

原因: 

 因为椭圆曲线加密的公式 左边是 $y^2$, 也就是说 $y$  的解释来自一个平方根, 可能是正值也可能是负值.

当我们在素数p阶的有限域上使用二进制算术计算椭圆曲线的时候，y坐标可能是奇数或者偶数，分别对应前面所讲的y值的正负符号。因此，为了区分y坐标的两种可能值，我们在生成压缩格式公钥时，如果y是偶数，则使用02作为前缀；如果y是奇数，则使用03作为前缀。这样就可以根据公钥中给定的x值，正确推导出对应的y坐标，从而将公钥解压缩为在椭圆曲线上的完整的点坐标。

![img](https://book.8btc.com/books/1/master_bitcoin/_book/4/Fig407.png)

新旧钱包的兼容性问题:

 当私钥从钱包中被导出时，较新的比特币客户端将使用一种不同的钱包导入格式（Wallet Import Format）。这种新的钱包导入格式可以用来表明该私钥已经被用来生成压缩的公钥，同时生成的比特币地址也是基于该压缩的公钥。这个方案可以解决导入私钥来自于老钱包还是新钱包的问题，同时也解决了通过公钥生成的比特币地址是来自于压缩格式公钥还是非压缩格式公钥的问题。最后新钱包在扫描区块链时，就可以使用对应的比特币地址去查找该比特币地址在区块链里所发生的交易。

**同样的私钥，不同的格式**

| 格式           | 私钥                                                         |
| -------------- | ------------------------------------------------------------ |
| Hex            | 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD |
| WIF            | 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn          |
| Hex-compressed | 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD01 |
| WIF-compressed | KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ         |

>“压缩格式私钥”是一个不当用词！私钥不是压缩的。WIF压缩格式的私钥只是用来表明他们只能被生成压缩的公钥和对应的比特币地址。相反地，“WIF压缩”编码的私钥还多出一个字节，因为这种私钥多了后缀“01”。该后缀是用来区分“非压缩格式”私钥和“压缩格式”私钥。

## 4.4 比特币钱包

定义:

>钱包是私钥的容器，通常通过有序文件或者简单的数据库实现。

==比特币钱包只包含私钥而不是比特币。==

每一个用户有一个包含多个私钥的钱包。钱包中包含成对的私钥和公钥。用户用这些私钥来签名交易，从而证明它们拥有交易的输出（也就是其中的比特币）。比特币是以交易输出的形式来储存在区块链中（通常记为vout或txout）。

### 4.4.1 非确定性(随机)钱包

定义:

> 最早的比特币客户端, 钱包只是随机生成的私钥集合. 这种类型的钱包被称作 零型非确定钱包.

==随机钥匙的缺点就是如果你生成很多，你必须保存它们所有的副本。==

![img](https://book.8btc.com/books/1/master_bitcoin/_book/4/Fig408.png)

### 4.4.2 确定性(种子)钱包

> 确定性, 或者"种子"钱包包含通过使用单项离散方程而可从公共的种子生成的私钥. 种子是随机生成的数字.  这种数字也含有比如索引号码或者可生成私钥的 "码链".

在确定性钱包中，种子足够收回所有的已经产生的私钥，所以只用在初始创建时的一个简单备份就足以搞定。并且种子也足够让钱包输入或者输出。这就很容易允许使用者的私钥在钱包之间轻松转移输入。

### 4.4.3 助记码词汇

> 助记码词汇是英文单词序列代表(编码)用作种子对应所确定性钱包的随机数.

单词的序列足以重新创建种子，并且从种子那里重新创造钱包以及所有私钥。

在首次创建钱包时，带有助记码的，运行确定性钱包的钱包的应用程序将会向使用者展示一个12至24个词的顺序。

单词的顺序就是钱包的备份。

它也可以被用来恢复以及重新创造应用程序相同或者兼容的钱包的钥匙。

助记码代码可以让使用者复制钱包更容易一些，因为它们相比较随机数字顺序来说，可以很容易地被读出来并且正确抄写。

### 4.4.4 分层确定性钱包(BIP0032/BIP0044)

确定性钱包被开发成更容易从单个"种子"中生成许多关键的钥匙.

分层确定性钱包包含从数结构所生成的钥匙. 这种母钥匙可以生成子钥匙的序列. 这些子钥匙又可以衍生出孙钥匙, 以此吴冲类推.

![img](https://book.8btc.com/books/1/master_bitcoin/_book/4/Fig409.png)

HD钱包提供了随机(不确定性)钥匙 两个优势

- 树状结构可以被用来表达额外的组织含义

  - 不同分支, 作用不同
  - 不同分支, 可以赋予不同的环境等

- 它可以允许让使用者去建立一个公共密钥的序列而不需要访问相对的私钥.

  这可允许HD钱包在不安全的服务器中使用或者在每笔交易中发行不同的公共钥匙。公共钥匙不需要被预先加载或者提前衍生，但是在服务器中不具有可用来支付的私钥。

#### 从种子种创造HD钱包

HD钱包从单个root seed中创建，为128到256位的随机数。HD钱包的所有的确定性都衍生自这个根种子。任何兼容HD钱包的根种子也可重新创造整个HD钱包。所以简单的转移HD钱包的根种子就让HD钱包中所包含的成千上百万的密钥被复制，储存导出以及导入。

![img](https://book.8btc.com/books/1/master_bitcoin/_book/4/Fig410.png)

#### 私有子密钥的衍生

分层确定性钱包使用CKD（child key derivation)方程去从母密钥衍生出子密钥。

子密钥衍生方程是基于单项哈希方程。这个方程结合了：

- 一个母私钥或者公共钥匙 （ECDSA未压缩键）
- 一个叫做链码（256 bits）的种子
- 一个索引号（32 bits）

链码是用来给这个过程引入看似的随机数据的，使得索引不能充分衍生其他的子密钥。因此，有了子密钥并不能让它发现自己的相似子密钥，除非你已经有了链码。最初的链码种子（在密码树的根部）是用随机数据构成的，随后链码从各自的母链码中衍生出来。

![img](https://book.8btc.com/books/1/master_bitcoin/_book/4/Fig411.png)

**使用衍生的子密钥**

子私钥不能从非确定性（随机）密钥中被区分出来。

因为**衍生方程是单向方程**，所以子密钥不能被用来发现他们的母密钥。

子密钥也不能用来发现他们的相同层级的姊妹密钥。

如果你有第n个子密钥，你不能发现它前面的（第n－1）或者后面的子密钥（n＋1）或者在同一顺序中的其他子密钥。

**只有母密钥以及链码才能得到所有的子密钥。**

**没有子链码的话，子密钥也不能用来衍生出任何孙密钥。**

你需要同时有子密钥以及对应的链码才能创建一个新的分支来衍生出孙密钥。

>子密钥、对应的公共钥匙以及比特币地址都不能从随机创造的密钥和地址中被区分出来。事实是它们所在的序列，在创造他们的HD钱包方程之外是不可见的。一旦被创造出来，它们就和“正常”钥匙一样运行了。

#### 拓展密钥

**密钥衍生方程可以被用来创造钥匙树上任何层级的子密钥。**

扩展密钥可以简单地被储存并且表示为简单的将256位密钥与256位链码所并联的512位序列。

有两种扩展密钥。

扩展的私钥是私钥以及链码的结合。

它可被用来衍生子私钥（子私钥可以衍生子公共密钥）公共钥匙以及链码组成扩展公共钥匙。

#### 公共子钥匙推导

分层确定性钱包的一个很有用的特点就是可以**不通过私钥而直接从公共母钥匙派生出公共子钥匙的能力**。这就给了我们两种去衍生子公共钥匙的方法：或者通过子私钥，再或者就是直接通过母公共钥匙。

![img](https://book.8btc.com/books/1/master_bitcoin/_book/4/Fig412.png)

​							扩展母公共钥匙来创造一个子公共钥匙

#### 硬化子密钥的衍生

扩展公共钥匙衍生一个分支公共钥匙的能力是很重要的，但牵扯一些风险。

访问扩展公共钥匙并不能得到访问子私人密钥的途径. 

但是,  因为**扩展公共钥匙包含有链码**，**如果子私钥被知道或者被泄漏的话，链码就可以被用来衍生所有的其他子私钥**。

一个简单地泄露的私钥以及一个母链码，

可以暴露所有的子密钥。

更糟糕的是，子私钥与母链码可以用来推断母私钥。

为了应对这种风险, HD钱包使用了一种叫做 hardened derivation 的替代衍生方程.

这就“打破”了母公共钥匙以及子链码之间的关系。

这个硬化衍生方程使用了母私钥去推到子链码，而不是母公共钥匙。

这就在母/子顺序中创造了一道“防火墙”——有链码但并不能够用来推算子链码或者姊妹私钥。

强化的衍生方程看起来几乎与一般的衍生的子私钥相同，不同的是是母私钥被用来输入散列方程中而不是母公共钥匙

![img](https://book.8btc.com/books/1/master_bitcoin/_book/4/Fig413.png)

​							子密密钥的强化衍生: 忽略母公共密钥.

当强化私钥衍生方程被使用时，得到的子私钥以及链码与使用一般衍生方程所得到的结果完全不同的。

得到的密钥“分支”可以被用来生产不易被攻击的扩展公共钥匙，

因为它所含的链码不能被用来开发或者暴露任何私钥。

强化的衍生也因此被用来在上一层级，使用扩展公共钥匙的的密钥树中创造“间隙”。

#### 正常衍生和强化衍生的索引号码

> 没懂, 再看几遍.....

#### HD钱包密钥识别符（路径）

HD钱包中的密钥是用“路径”命名的，且每个级别之间用斜杠（/）字符来表示

由主私钥衍生出的私钥起始以“m”打头。因此，第一个母密钥生成的子私钥是m/0。第一个公共钥匙是M/0。第一个子密钥的子密钥就是m/0/1，以此类推。

密钥的“祖先”是从右向左读，直到你达到了衍生出的它的主密钥。举个例子，标识符m/x/y/z描述的是子密钥m/x/y的第z个子密钥。而子密钥m/x/y又是m/x的第y个子密钥。m/x又是m的第x个子密钥。

**HD钱包路径的例子**

| HD path     | 密钥描述                                                     |
| ----------- | ------------------------------------------------------------ |
| m/0         | 从主私钥（m）衍生出的第一个（0）子密钥。                     |
| m/0/0       | 第一个私人子密钥（m/0）的子密钥。                            |
| m/0'/0      | 第一个子强化密钥first hardened child（m/0'）的第一个常规子密钥。 |
| m/1/0       | 第2个子密钥（m/1）的第一个常规子密钥                         |
| M/23/17/0/0 | 主密钥衍生出的第24个子密钥所衍生出的第17个子密钥的第一个子密钥所衍生出的第一个子密钥。 |

#### HD钱包树状结构的导航

HD钱包树状结构提供了极大的灵活性。

每一个母扩展密钥有40已个子密钥：20亿个常规子密钥和20亿个强化子密钥。

而每个子密钥又会有40亿个子密钥并且以此类推。

只要你愿意，这个树结构可以无限类推到无穷代。

但是，又由于有了这个灵活性，对无限的树状结构进行导航就变得异常困难。

尤其是对于在不同的HD钱包之间进行转移交易，因为内部组织到内部分支以及亚分支的可能性是无穷的。

**两个比特币改进建议（BIPs）提供了这个复杂问的解决办法——通过创建几个HD钱包树的提议标准。BIP0043提出使用第一个强化子索引作为特殊的标识符表示树状结构的“purpose”**

**BIP0044 HD 钱包结构的例子**

| HD 路径          | 主要描述                                 |
| ---------------- | ---------------------------------------- |
| M/44'/0'/0'/0/2  | 第三个收到公共钥匙的主比特币账户         |
| M/44'/0'/3'/1/14 | 第十五改变地址公钥的第四个比特币账户     |
| m/44'/2'/0'/0/1  | 为了签署交易的在莱特币主账户的第二个私钥 |

## 4.5 高级密钥和地址

### 4.5.1 加密私钥（BIP0038）

私钥必须保密。私钥的机密性需求事实情况是，在实践中相当难以实现，因为该需求与同样重要的安全对象可用性相互矛盾。当你需要为了避免私钥丢失而存储备份时，会发现维护私钥私密性是一件相当困难的事情。通过密码加密内有私钥的钱包可能要安全一点，但那个钱包也需要备份。

BIP0038提出了一个通用标准，使用**一个口令加密私钥并使用Base58Check对加密的私钥进行编码**，这样加密的私钥就可以安全地保存在备份介质里，安全地在钱包间传输，保持密钥在任何可能被暴露情况下的安全性。这个加密标准使用了AES，这个标准由NIST建立，并广泛应用于商业和军事应用的数据加密。

### 4.5.2 P2SH (Pay-to-Script Hash)和多重签名地址

**以数字3开头的比特币地址是P2SH地址**

有时被错误的称谓多重签名或多重签名地址。

他们指定比特币交易中受益人作为哈希的脚本，而不是公钥的所有者

> P2SH 不一定是多重签名的交易。虽然P2SH地址通常都是代表多重签名，但也可能是其他类型的交易脚本。

# 第五章 交易

## 5.1 简介

根据比特币系统的设计原理， 系统中任何其它部分都是为了确保比特币交易可以被生成，能在比特币网络中得以传播和通过验证， 并最终添加乳全球比特币交易总账簿（比特币区块链）

比特币交易的本质是数据结构， 这些数据结构中含有比特币交易参与者价值转移的相关信息。

比特币区块链是全球复式记账 总帐薄，咩哥比特币交易都是在比特币区块链上一个公开记录。

## 5.2 比特币交易的生命周期

始于：被创建的那一刻 （诞生 origination）

随后： 比特币交易会被一个或者多个签名加密， 这些签名标志着对该交易指向的比特币资金的使用许可。

其次： 比特币交易被广播到比特币网络中。（在比特币网络中， 每一个节点验证， 并将交易在网络中进行广播， 直到这币交易被网络中大多数节点接收。）

最终： 比特币交易被一个挖矿节点验证，并被添加到区块链上一个记录着虚火比特币交易的区块中。

重新开启比特币的交易生命周期：

> 比特币交易被记录并且被足够多的后续区块确认，便成为比特币总帐薄的一部分， 并被所有比特币参与者认可为有效交易。于是 被这笔交易分配到一个新所有者名下的比特币资金可以在新的交易中被使用

### 5.2.1 创建比特币交易

比特币交易 与支票相似， 一笔比特币交易其实是一个有着货币转移目的的工具， 这个工具只有在交易被执行时才会在金融体系中体现， 而且交易发起人并不一定是签署交易的人。

**比特币交易可以被任何人在线上或线下创建，即便创建这笔交易的人不是这个账户的授权签字人**

支票是指定一个特定账户作为资金来源的，但是比特币交易指定以往的一笔交易作为其资金来源，而不是一个特定账户。

一旦一笔比特币交易被创建， 它会被资金所有者（们）签名。 如果它是合法创建并签名的，则该笔交易现在就是有效的， 它包含了转移着币资金所需要的所有信息。 最终， 有效的比特币交易必须能接入比特币网络，从而使之能被传送， 直至抵达下一个登记在公共总帐薄（区块链）的挖矿节点。

### 5.2.2	广播交易至比特币网络

重要性：

​	一笔交易需要传递至比特币网络，才能被传播， 也才能加入区块链中。

实际：

一笔比特币交易只有300到400字节的数据， 而且它们必须被发送至成千上万个比特币节点中的任意一个。只要发送者能使用多于一个比特币节点来确保这个币交易被传播， 那么发送者并不需要信任用来传播该交易的单一节点。

相应地，这些节点不需要信任发送者，也不用建立发送者的“身份档案”。

本质：

​	因为比特币将金钱变成了一种数据结构， 所以本质上是不能阻止任何人创建并执行比特币交易的。

### 5.2.3 比特币交易在比特币网络中的传播

一旦一笔比特币交易被发送到任意一个连接至比特币网络的节点， 这笔交易将会被改节点验证。

 如果交易被**验证有效**， 该节点将会将这笔交易传播到这个节点所连接的其它节点。 同时交易发起者会收到一条表示交易有效并被接受的返回信息。

如果交易被**验证为无效**， 这个节点会拒绝接受着币交易且同时返回给交易发起者一条表示交易被拒绝的信息。 



比特币网络是一个点对点网络，这意味着每一个比特币节点都连接到一些其他的比特币节点（这些其他的节点是在启动点对点协议时被发现的）。

整个比特币网络形成了一个松散地连接、且没有固定拓扑或任何结构的“蛛网”——这使得所有节点的地位都是同等的。

## 5.3 交易结构

比特币交易是一个含有 输入值和输出值的数据结构， 该数据结构植入了将一笔资金从初识点（输入值）转移至目标地址（输出值）的代码信息。

交易结构的构成

| 大小    | 字段     | 描述                   |
| ------- | -------- | ---------------------- |
| 4字节   | 版本     | 明确这笔交易参照的规则 |
| 1-9字节 | 输入数量 | 被包含的输入的数量     |
| 不定    | 输入     | 一个或多个交易输入     |
| 1-9字节 | 输出数量 | 被包含的输出的数量     |
| 不定    | 输出     | 一个或多个交易输出     |
| 4字节   | 时钟时间 | 一个UNIX时间戳或区块号 |

**交易的锁定时间**

锁定时间定义了能被加到区块链里的最早的交易时间。

在大多数交易里，它被设置成0，用来表示立即执行。

如果锁定时间不是0并且小于5亿，就被视为区块高度，意指在这个指定的区块高度之前，该交易没有被包含在区块链里。如果锁定时间大于5亿，则它被当作是一个Unix纪元时间戳（从1970年1月1日以来的秒数），并且在这个指定时点之前，该交易没有被包含在区块链里。锁定时间的使用相当于将一张纸质支票的生效时间予以后延。

## 5.4  交易的输出和输入

比特币交易的最基本单位是未经使用的一个交易输出， 简称UTXO。

UTXO是不能被再分割，被所有者锁住或记录与区块链中的并被整个网络识别成货币单位的一定量的比特币货币。

**在比特币的世界里既没有账户， 也没有余额， 只有分散到区块链里的UTXO**

被交易消耗的UTXO被称为交易输入， 有交易创建的UTXO被称为交易输出。 通过这种方式，一定量的比特币价值在不同所有者之间转移，并咋交易链中消耗和创建UTXO。 一笔比特币交易通过使用所有者的签名来解锁UTXO， 并通过使用的新的所有者的比特币地址来锁定并创建UTXO

对于输入和输出链来说， 又一个例外 是一种特殊的交易类型， 称为 **Coinbase交易**

### 5.4.1 交易输出

每一笔比特币交易创造输出， 输出都会被比特币账簿记录下来。

几乎所有的输出都能创造一定数量的可以用支付的比特币， 也就是UTXO

UTXO 被每一个全节点比特币客户端在一个储存与内存中的数据库所追踪该数据库也被称为“UTXO集” 或者 “UTXPO池”。 新的交易从UTXO 集中消耗（支付）一个或者多个输出。

交易输出包含两部分

- 一定量的比特币， 被命名为”聪“ ， 是比特币最小单位；
- 一个锁定脚本， 也被当作是”障碍“， 提出支付输出所必须被满足的条件以”锁住“这笔总额

交易输出结构

| 尺寸                  | 字段         | 说明                             |
| --------------------- | ------------ | -------------------------------- |
| 8个字节               | 总量         | 用聪表示的比特币值（10-8比特币） |
| 1–9个字节（可变整数） | 锁定脚本尺寸 | 用字节表示的后面的锁定脚本长度   |
| 变长                  | 锁定脚本     | 一个定义了支付输出所需条件的脚本 |

**支付条件（障碍）**

交易输出把用聪表示的一定数量的比特币，和特定的定义了支付所必须被满足的条件的障碍，或者叫锁定脚本，关联到了一起。

大多数情况下， 锁定脚本会把输出锁定一个特定的比特币地址上，从而把一定数量的比特币的所有权转移到新的所有者上。

### 5.4.2 交易输入

交易输入是指向 UTXO的指针。它们指向特定的 UTXO，并被交易哈希和在区块链中记录UTXO的序列号作为参考。

若想支付UTXO，一个交易的输入也需要包含一个解锁脚本，用来满足UTXO的支付条件。

解锁脚本通常是一个签名，用来证明对于在锁定脚本中的比特币地址拥有所有权。

一旦UTXO被选中，钱包会成为每个UTXO生成包含签名的解锁脚本， 由此让它们变得可以通过满足锁定脚本的条件被支付。

**交易输入的结构**

| 尺寸                  | 字段         | 说明                                       |
| --------------------- | ------------ | ------------------------------------------ |
| 32个字节              | 交易         | 指向交易包含的被花费的UTXO的哈希指针       |
| 4个字节               | 输出索引     | 被花费的UTXO的索引号，第一个是0            |
| 1–9个字节（可变整数） | 解锁脚本尺寸 | 用字节表示的后面的解锁脚本长度             |
| 变长                  | 解锁脚本     | 一个达到UTXO锁定脚本中的条件的脚本         |
| 4个字节               | 序列号       | 目前未被使用的交易替换功能，设成0xFFFFFFFF |

序列号是用来覆盖在交易锁定时间之前失效的交易，这是一项目前没有在比特币中用到的功能。 大多数交易把这个值设置成最大的整数（OxFFFFFFFF）并且被比特币网络忽略。 如果一次交易有非零的锁定时间，那么它至少需要一个序列号比 OxFFFFFFFFFF 低的输入来激活锁定时间。

### 5.4.3 交易费

本质

> 大多数交易包含交易费，这是为了在网络安全方面给比特币矿工一种补偿。

交易费 可以当作是为了包含（挖矿）一笔交易到下一个区块的一种鼓励，也可当作是对欺诈交易和任何种类的系统的滥用，在每笔交易上通过征收一笔小成本的税而造成的一种妨碍。

交易费呗挖出这个区块的矿工得到，并且记录在这个交易的区块链中。

**交易费基于交易的尺寸， 用千字节来计算， 而不是比特币的价值。**

==交易费基于市场所设置，生效与比特币网络中。== 

交易费影响处理优先级，这意味着有足够费用的交易会更可能地被包含在下一挖出的区块中；

原则：

> 交易费不是强制的，而且没有交易费的交易也许最终会被处理， 但是，包含交易费将提高处理优先级。

### 5.4.4 把交易费加到交易中

==交易的数据结构没有交易费这个字段==

> 交易费通过 所有输入的总和， 以及所有输出的总和之间的差来表示。

$$
交易费 = \sum{所有输入} - \sum{所有输出}
$$



## 5.5 交易链条和孤立交易

当一条交易链被整个网络传送时，它们并不能总是按照相同的顺序到达目的地。

因为顺序的不同，会发生 没有父交易。 而没有父交易的交易池被称作孤立交易池。 

一旦接收到了父交易，所有与这个父交易创建的UTXO有关的孤块会从池中释放出来，递归地重新验证，然后整条交易链就会被交易池包括进去，并等待着被区块所挖走。

交易链可以是任意长度并且可以被任意数量的批次同时传走。

在孤立池中保留孤块的机制保证了其他合法的交易不会只是因为父交易被耽误了而被抛弃，并且无论接收顺序，最终整个链会以正确的顺序重新构造出来。

==内存中储存的鼓励交易数量是有限制的， 这是为了防止针对比特币节点的拒绝服务攻击（DoS）==

这个限制被定义在比特币涉及到客户端的源代码中的 **MAX_ORPHAN_TRANSACTIONS**

如果池中的孤立交易数量达到了`MAX_ORPHAN_TRANSACTIONS`，一个或多个的、被随机选出的孤立交易会被池抛弃，直到池的大小回到限制以内。（疑问？被抛弃的孤立交易该如何？）

## 5.6 比特币交易脚本和脚本语言

比特币客户端通过执行一个用类Forth脚本语言编写的脚本验证比特币交易。锁定脚本被写入UTXO，同时它往往包含一个用同种脚本语言编写的签名

> 比特币交易验证并不基于一个不变的模式，而是通过运行脚本语言来实现。这种语言可以表达出多到数不尽的条件变种。 这也是比特币作为一种“可编程的货币”所拥有的权利。

### 5.6.1 脚本创建（锁定与解锁）

- 锁定脚本（脚本公钥代码）

  锁定脚本是一个放在一个输出值上的“障碍”， 同时它明确了今后花费这笔输出的条件

- 解锁脚本

  解锁脚本是一个“解决”或满足被锁定脚本在一个输出上设定的花费条件的脚本，同时它将允许输出被消费。

![img](https://book.8btc.com/books/1/master_bitcoin/_book/5/Fig501.png)

### 5.6.2 脚本语言

比特币交易脚本语言，也称为脚本，是一种基于逆波兰表示法的基于堆栈的执行语言。

# 第六章 比特币网络

## 6.1 P2P网络架构

比特币采用了基于国际互联网（Internet）的P2P（peer-to-peer）网络架构。

P2P是指位于同一网络中的没台计算机哦度彼此对等，各个节点共同提供网络服务，不存在任何“特殊”节点。每个网络节点以“扁平（flat）” 的拓扑结构 相互连通。

在P2P网络中不存在任何服务端（server），中央化的服务，以及层级结构。

P2P网络的节点之间交互运作，协同处理：每个节点对外提供服务的同时也适用网络中其他节点所提供的服务。

所以 P2P网络也因此具有可靠性，去中心化，以及开放性。

比特币不仅仅是选择拓扑结构这样简单。比特币被设计为一种点对点的数字现金系统，它的网络架构既是这种核心特性的反映，也是该特性的基石。

## 6.2 节点类型及分工

P2P网络中的各个节点相互对等，但是根据所提供的功能不同，各个节点又有不同的分工

- 路由
- 区块链数据库
- 挖矿
- 钱包服务

![img](https://book.8btc.com/books/1/master_bitcoin/_book/6/Fig601.png)

全节点： 节点保有一份完整的，最新的区块链拷贝。可以独立自主地地校验所有的交易，不需要借由其他外部参照物。 

轻量级节点（SPV节点）： 只保留区块链的一部分， 通过 “简易支付验证（SPV）“的方式来完成交易验证。

挖矿节点通过运行在特殊硬件设备上的==工作量证明（proof-of-work）算法==，以相互竞争的方式创建新的区块。一些挖矿节点同时也是全节点，保有区块链的完整拷贝；还有一些参与矿池挖矿的节点是轻量级节点，它们必须依赖矿池服务器维护的全节点进行工作。

钱包 也可以是 全节点， 也可以是 SPV 节点。 大多数是SPV节点。

![img](https://book.8btc.com/books/1/master_bitcoin/_book/6/Fig602.png)

## 6.3 拓展比特币网络

![img](https://book.8btc.com/books/1/master_bitcoin/_book/6/Fig603.png)

## 6.4 网络发现

当新的网络节点启动后，为了能够参与协同运作，它必须发现网络中的其他比特币节点。新的网络节点必须发现至少一个网络中存在的节点并建立连接。由于比特币网络的拓扑结构并不基于节点间的地理位置，因此各个节点之间的地理信息完全无关。在新节点连接时，可以随机选择网络中存在的比特币节点与之相连。

**节点通常采用TCP协议，使用8333端口。**



客户端会维持一个列表，那里列出了那些长期稳定运行的节点，这种节点被称为“种子节点（seed nodes）”

链接 种子节点的好处就是 可以通过种子节点 来发现其他节点。

![img](https://book.8btc.com/books/1/master_bitcoin/_book/6/Fig604.png)

当建立一个或多个连接后，新节点将一条包含自身IP地址的addr消息发送给其相邻节点。相邻节点再将此条addr消息依次转发给它们各自的相邻节点，从而保证新节点信息被多个节点所接收、保证连接更稳定。

![img](https://book.8btc.com/books/1/master_bitcoin/_book/6/Fig605.png)

节点必须连接到若干不同的对等节点才能在比特币网络中建立通向比特币网络的种类各异的路径（path）。



## 6.5 全节点

全节点是指维持包含全部交易信息的完整区块链的节点。更加准确地说，这样的节点应当被称为完整区块链节点”。

## 6.6 交换“库存清单”

一个全节点连接到对等节点之后，第一件要做的事情就是构建完整的区块链。

如果该节点是一个全新节点，那么它就不包含任何区块链信息，它只知道一个区块——静态植入在客户端软件中的创世区块。

新节点需要下载从0号区块（创世区块）开始的数十万区块的全部内容，才能跟网络同步、并重建全区块链。

![img](https://book.8btc.com/books/1/master_bitcoin/_book/6/Fig606.png)

​                                                 节点通过从对等节点读取区块来同步区块链

## 6.7 简单支付验证（SPV）节点

SPV节点只需下载区块头，而不用下载包含在每个区块中的交易信息。由此产生的不含交易信息的区块链，大小只有完整区块链的1/1000。

简易支付验证是通过参考交易在**区块链中的深度**，而不是高度，来验证它们。

一个拥有完整区块链的节点会构造一条验证链，这条链是由沿着区块链按时间倒序一直追溯到创世区块的数千区块及交易组成。而一个SPV节点会验证所有区块的链（但不是所有的交易），并且把区块链和有关交易链接起来。

==**Merkle 树**==

>完整的区块链节点是通过检查整个链中在它之下的数千个区块来保证这个UTXO没有被支付，从而验证交易。而SPV节点是通过检查在其上面的区块将它压在下面的深度来验证交易。

SPV节点使用的是一条getheaders消息，而不是getblocks消息来获得区块头。

发出响应的对等节点将用一条headers消息发送多达2000个区块头。

这一过程和全节点获取所有区块的过程没什么区别。

SPV节点还在与对等节点的连接上设置了过滤器，用以过滤从对等节点发来的未来区块和交易数据流。任何目标交易都是通过一条getdata的请求来读取的。对等节点生成一条包含交易信息的tx消息作为响应。

![img](https://book.8btc.com/books/1/master_bitcoin/_book/6/Fig607.png)

由于SPV节点需要读取特定交易从而选择性地验证交易，这样就又产生了隐私风险。与全区块链节点收集每一个区块内的全部交易所不同的是，SPV节点对特定数据的请求可能无意中透露了钱包里的地址信息。

## 6.8 Bloom过滤器

Bloom 过滤器是一个允许用户描述特定的关键词组合而不必精确表述的基于概率的过滤方法。

Bloom过滤器可以让SPV节点指定交易的搜索模式，该搜索模式可以基于准确性或私密性的考虑被调节。一个非常具体的Bloom过滤器会生成更准确的结果，但也会显示该用户钱包里的使用的地址；反之，如果过滤器只包含简单的关键词，更多相应的交易会被搜索出来，在包含若干无关交易的同时有着更高的私密性。

